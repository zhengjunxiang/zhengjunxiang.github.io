<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>ZhengJX&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ZhengJX's Blog">
<meta property="og:url" content="http://zhengjunxiang.github.io/index.html">
<meta property="og:site_name" content="ZhengJX's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhengJX's Blog">
  
    <link rel="alternative" href="/atom.xml" title="ZhengJX&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars.githubusercontent.com/u/17134351?v=3" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ZhengJX</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/zhengjunxiang" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">ZhengJX</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars.githubusercontent.com/u/17134351?v=3" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">ZhengJX</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zhengjunxiang" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-es6-箭头函数学习记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/es6-箭头函数学习记/">es6-箭头函数学习记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##JS中的箭头函数<br>箭头函数在JS里并不算是个新鲜的玩意儿，一直以来，JS都支持<code>--&gt;</code>这样的箭头符号。<br>很早的时候有些浏览器还不支持JS,当时的人们为了兼容这些浏览器，需要这样写JS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script language=&quot;javascript&quot;&gt;</div><div class="line">&lt;--</div><div class="line">    alert(&apos;Joe&apos;);</div><div class="line">// --&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>这段代码在不支持JS的浏览器里会被解读成2个未知标签和一段html注释。在支持JS的浏览器里，JS引擎会把<!--和-->看成是单行注释的开始。需要说明的是，–&gt;仅仅是在一行的开头才能表示这一行是注释，其余情况–&gt;是一个操作符，表示goes to的含义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function countdown(n) &#123;</div><div class="line">    while (n --&gt; 0) &#123;</div><div class="line">        alert(n);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码确实能够正常运行哦。当你给<code>countdown</code>函数传入一个大于0的参数时，这个循环能够一直运行，直到n变为0为止。<br>此箭头非彼箭头，以上讲述的–&gt;并不是我们今天要讲的主角，大家权当拓展下JS知识，下面让我们进入正题。</p>
<h2 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h2><p>箭头函数是ES6新增的特性之一，它为JS这门语言提供了一种全新的书写函数的语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var double = nums.map(function (v) &#123;</div><div class="line">    return 2 * n;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// ES6</div><div class="line">var double = nums.map(v =&gt; 2 * n);</div></pre></td></tr></table></figure></p>
<p>箭头函数简化了原先的函数语法，不需要再写<code>function</code>，如果函数体只有一行代码的话连<code>return</code>都不用写，这个特性对于热衷于简化流程和工作的程序员来说相当对胃口。</p>
<p>使用箭头函数有几个注意点：</p>
<p>##函数体<br>箭头函数支持两种模式的函数体写法，我们姑且叫他简洁函数体和块级函数体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 简洁函数体</div><div class="line">var fn = x =&gt; x * x;</div><div class="line">// 块级函数体</div><div class="line">var fn = (x, y) =&gt; &#123;return x + y;&#125;;</div></pre></td></tr></table></figure></p>
<p>简介函数体默认会把表达式的结果返回，块级函数体需要手动<code>return</code>。如果想要返回一个对象又想使用简洁函数体的话，需要这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var fn = () =&gt; (&#123;&#125;);</div><div class="line">fn();   // &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>如果写成<code>var fn = () =&gt; {};</code>，那么执行<code>fn()</code>只能返回<code>undefined</code>。</p>
<p>###this<br>用<code>function</code>生成的函数会定义一个自己的<code>this</code>，而箭头函数没有自己的<code>this</code>，而是会和上一层的作用域共享<code>this</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">    this.age = 0;</div><div class="line">    var self = this;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        self.age++;</div><div class="line">        console.log(self.age);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;</div><div class="line">var p = new Person();</div></pre></td></tr></table></figure></p>
<p>这段代码里，<code>setTimeout</code>的参数<code>function</code>中需要操作外层的<code>age</code>属性，必须要把<code>this</code>赋值给<code>self</code>，然后通过<code>self</code>来获取到<code>age</code></p>
<p>如果使用箭头函数则省事很多，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">    this.age = 0;</div><div class="line">    setTimeout(() =&gt; &#123;</div><div class="line">        this.age++;</div><div class="line">        console.log(this.age);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;</div><div class="line">var p = new Person();</div></pre></td></tr></table></figure></p>
<p>##apply &amp; call<br>由于箭头函数已经绑定了<code>this</code>的值，即使使用<code>apply</code>或者<code>call</code>也不能只能起到传参数的作用，并不能强行改变箭头函数里的<code>this</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var adder = &#123;</div><div class="line">    x: 1,</div><div class="line">    add1: function (y) &#123;</div><div class="line">        var fn = v =&gt; v + this.x;</div><div class="line">        return fn(y);</div><div class="line">    &#125;,</div><div class="line">    add2: function (y) &#123;</div><div class="line">        var fn = v =&gt; v + this.x;</div><div class="line">        var whatever = &#123;</div><div class="line">            x: 2</div><div class="line">        &#125;;</div><div class="line">        return fn.call(whatever, y);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">adder.add1(1);    // 2</div><div class="line">adder.add2(1);    // 仍然是2</div></pre></td></tr></table></figure></p>
<p>##arguments<br>普通函数里<code>arguments</code>代表了调用时传入的参数，但是箭头函数不然，在箭头函数中无法使用<code>arguments</code><br>当然，<code>ES6</code>中也有办法可以让箭头函数像普通函数一样使用类似于<code>arguments</code>这样的类数组对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var fn = (...rest) =&gt; rest[0];</div><div class="line">fn(2);    // 2</div></pre></td></tr></table></figure></p>
<p><code>...rest</code>也是<code>ES6</code>的一个新特性，之后会介绍。</p>
<p>##不能被new<br>箭头函数不能与<code>new</code>关键字一起使用，会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Fn = () =&gt; &#123;</div><div class="line">    this.a = 1;</div><div class="line">&#125;;</div><div class="line">var f = new Fn();    // Error</div></pre></td></tr></table></figure></p>
<p>##使用场景<br>在我看来，箭头函数几乎可以完全取代<code>function</code>，除非是函数需要进行递归或者需要可变的<code>this</code>对象，其他场景我认为都可以使用箭头函数。</p>
<p>##参考资料</p>
<ul>
<li><a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/" target="_blank" rel="external">ES6 In Depth: Arrow functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">Arrow functions</a></li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/01/es6-箭头函数学习记/" class="archive-article-date">
  	<time datetime="2016-11-01T07:58:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-01</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-es6-箭头函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/es6-箭头函数/">es6 箭头函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个箭头函数很简单，基本语法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">([param] [, param]) =&gt; &#123;</div><div class="line">    statements</div><div class="line">&#125;</div><div class="line">param =&gt; expression</div></pre></td></tr></table></figure></p>
<p>param是参数，根据参数个数的不同，分为几种情况：<br>() =&gt; {…} // 零个参数用（）表示<br>x =&gt; {…} // 一个参数可以省略（）；<br>(x, y) =&gt; {…} // 多个数不能省略（）；<br>当然，和普通函数一样，箭头函数也可以使用ES6新增的<strong>默认参数</strong>和<strong>剩余参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var func1 = (x = 1, y = 2) =&gt; x + y;</div><div class="line">func1() // 得到3</div><div class="line">var func2 = (x, ...args) =&gt; &#123;console.log(args)&#125;;</div><div class="line">func2(1,2,3); // 输出 [2,3];</div></pre></td></tr></table></figure></p>
<p>箭头函数允许多行语句或者单行表达式作为函数体。多行语句要用{}括起来；单行表达式不需要{}，并且作为函数返回值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x =&gt; &#123;return x * x&#125;; // 函数返回 x * x</div><div class="line">x =&gt; x * x; // 同上一行</div><div class="line">x =&gt; return x * x; // SyntaxError 报错，不能省略 &#123;&#125;</div><div class="line">x =&gt; &#123; x * x&#125;; // 合法，没有定义返回值，返回 undefined</div></pre></td></tr></table></figure></p>
<p>箭头函数也是JS函数的一种，所以之前的instanceof和typeof依然可用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var func1 = () =&gt; &#123;&#125;;</div><div class="line">func1 instanceof Function; // true</div><div class="line"></div><div class="line">var func2 = () =&gt; &#123;&#125;;</div><div class="line">typeof func2; // &quot;function&quot;</div></pre></td></tr></table></figure></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>箭头函数内部没有 constructor 方法，也没有 prototype，所以不支持 new 操作。new (() =&gt; {}) 会触发 TypeError 报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new (() =&gt; &#123;&#125;) // Uncaught TypeError: () =&gt; &#123;&#125; is not a constructor(...)</div></pre></td></tr></table></figure></p>
<p>箭头函数没有自己内部的 this 指针。在箭头函数中， this 指针是继承于其所在的作用域。(个人理解为箭头函数不具备函数作用域，相当于表达式，this即为箭头函数被调用时外层的this)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">var test = &#123;</div><div class="line">    a: 100,</div><div class="line">    c: function()&#123;</div><div class="line">        console.log(this.a); </div><div class="line">    &#125;,</div><div class="line">    d: ()=&gt;&#123;console.log(this.a)&#125; </div><div class="line">&#125;</div><div class="line">test.c();//100</div><div class="line">test.d();//1</div></pre></td></tr></table></figure></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/01/es6-箭头函数/" class="archive-article-date">
  	<time datetime="2016-11-01T06:25:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-01</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JS-进阶-闭包，作用域链，垃圾回收，内存泄露" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/26/JS-进阶-闭包，作用域链，垃圾回收，内存泄露/">[ JS 进阶 ] 闭包，作用域链，垃圾回收，内存泄露</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>关于闭包，最近查看了一些资料，看到有不错的文章，邪王一起学习！！</p>
</blockquote>
<p>##1.什么是闭包？<br><strong>来看一些关于闭包的定义：</strong></p>
<ol>
<li>闭包是指有权访问另一个函数作用域中变量的函数 –《JS高级程序设计第三版》 p178</li>
<li>函数对象可以通过作用域链相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为 ‘闭包’ 。 –《JS权威指南》 p183</li>
<li>内部函数可以访问定义它们的外部函数的参数和变量(除了this和arguments)。 –《JS语言精粹》 p36</li>
</ol>
<p><strong>来个定义总结</strong></p>
<ol>
<li>可以访问外部函数作用域中变量的<code>函数</code></li>
<li>被内部函数访问的外部函数的变量可以保存在外部函数作用域内而不被回收—这是核心，后面我们遇到闭包都要想到，我们要重点关注被闭包引用的这个变量。</li>
</ol>
<p><strong>来创建个简单的闭包</strong></p>
<ul>
<li><code>var say = sayName()</code> ：返回了一个匿名的内部函数保存在变量say中，并且引用了外部函数的变量name，由于垃圾回收机制，sayName函数执行完毕后，变量name并没有被销毁。</li>
<li><code>say()</code> ：执行返回的内部函数，依然能访问变量name,输出 ‘jozo’ .</li>
</ul>
<p>##2. 闭包中的作用域链<br>理解作用域链对理解闭包也很有帮助。</p>
<p>变量在作用域中的查找方式应该都很熟悉了，其实这就是顺着作用域链往上查找的。</p>
<p><strong>当函数被调用时：</strong></p>
<ol>
<li>先创建一个执行环境(execution context),及相应的作用域链；</li>
<li>将arguments和其他命名参数的值添加到函数的活动对象(activation object)<br>作用域链：当前函数的活动对象优先级最高，外部函数的活动对象次之，外部函数的外部函数的活动对象依次递减，直至作用域链的末端–全局作用域。优先级就是变量查找的先后顺序；</li>
</ol>
<p><strong>先来看个普通的作用域链：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sayName(name)&#123;</div><div class="line">    return name;</div><div class="line">&#125;</div><div class="line">var say = sayName(&apos;jozo&apos;);</div></pre></td></tr></table></figure></p>
<p>这段代码包含两个作用域：a.全局作用域；b.sayName函数的作用域，也就是只有两个变量对象，当执行到对应的执行环境时，该变量对象会成为活动对象，并被推入到执行环境作用域链的前端，也就是成为优先级最高的那个。 看图说话：<br><img src="https://segmentfault.com/img/bVlOlU/view" alt=""><br>在创建sayName()函数时，会创建一个预先包含变量对象的作用域链，也就是图中索引为1的作用域链，并且被保存到内部的[[Scope]]属性中，当调用sayName()函数的时候，会创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起作用域链，此后，又有一个活动对象（图中索引为0）被创建，并被推入执行环境作用域链的前端。</p>
<p>一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域。但是，闭包的情况又有所不同 ：</p>
<p><strong>再来看看看闭包的作用域链：</strong></p>
<figure class="highlight plain"><figcaption><span>sayName(name)&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    return function()&#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var say = sayName(&apos;jozo&apos;);</div></pre></td></tr></table></figure>
<p><strong>这个闭包实例比上一个例子多了一个匿名函数的作用域：</strong><br><img src="https://segmentfault.com/img/bVlOm2" alt=""></p>
<p>在匿名函数从sayName()函数中被返回后，它的作用域链被初始化为包含sayName()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在sayName()中定义的所有变量和参数，更为重要的是，sayName()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链依然在引用这个活动对象，换句话说，sayName()函数执行完后，其执行环境的作用域链会被销毁，但他的活动对象会留在内存中，知道匿名函数会销毁。这个也是后面要讲到的内存泄露的问题。</p>
<p>##3. 闭包的实例<br><strong>实例1：实现累加</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 方式1</div><div class="line">var a = 0;</div><div class="line">var add = function()&#123;</div><div class="line">    a++;</div><div class="line">    console.log(a)</div><div class="line">&#125;</div><div class="line">add();</div><div class="line">add();</div><div class="line">//方式2 ：闭包</div><div class="line">var add = (function()&#123;</div><div class="line">    var  a = 0;</div><div class="line">    return function()&#123;</div><div class="line">        a++;</div><div class="line">        console.log(a);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line">console.log(a); //undefined</div><div class="line">add();</div><div class="line">add();</div><div class="line"></div><div class="line">相比之下方式2更加优雅，也减少全局变量，将变量私有化</div></pre></td></tr></table></figure></p>
<p><strong>实例2 ：给每个li添加点击事件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var oli = document.getElementsByTagName(&apos;li&apos;);</div><div class="line">var i;</div><div class="line">for(i = 0;i &lt; 5;i++)&#123;</div><div class="line">    oli[i].onclick = function()&#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(i); // 5</div><div class="line"></div><div class="line">//执行匿名函数</div><div class="line">(function()&#123;</div><div class="line">   alert(i);  //5</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>上面是一个经典的例子，我们都知道执行结果是都弹出5，也知道可以用闭包解决这个问题，但是我刚开始始终不能明白为什么每次弹出都是5，为什么闭包可以解决这问题。后来捋一捋还是把它弄清晰了：</p>
<p>a. 先来分析没用闭包前的情况：for循环中,我们给每个li点击事件绑定了一个匿名函数，匿名函数中返回了变量i的值，当循环结束后，变量i的值变为5，此时我们再去点击每个li，也就是执行相应的匿名函数(看上面的代码)，这是变量i已经是5了，所以每个点击弹出5. 因为这里返回的每个匿名函数都是引用了同一个变量i，如果我们新建一个变量保存循环执行时当前的i的值，然后再让匿名函数应用这个变量，最后再返回这个匿名函数，这样就可以达到我们的目的了，这就是运用闭包来实现的！</p>
<p>b. 再来分析下运用闭包时的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var oli = document.getElementsByTagName(&apos;li&apos;);</div><div class="line">     var i;</div><div class="line">     for(i = 0;i &lt; 5;i++)&#123;</div><div class="line">         oli[i].onclick = (function(num)&#123;</div><div class="line">             var a = num; // 为了说明问题</div><div class="line">             return function()&#123;</div><div class="line">                 alert(a);</div><div class="line">             &#125;</div><div class="line">         &#125;)(i)</div><div class="line">     &#125;</div><div class="line">     console.log(i); // 5</div></pre></td></tr></table></figure>
<p>这里for循环执行时，给点击事件绑定的匿名函数传递i后立即执行返回一个内部的匿名函数，因为参数是按值传递的，所以此时形参num保存的就是当前i的值,然后赋值给局部变量 a，然后这个内部的匿名函数一直保存着a的引用，也就是一直保存着当前i的值。 所以循环执行完毕后点击每个li，返回的匿名函数执行弹出各自保存的 a 的引用的值。</p>
<p>##4. 闭包的运用<br>我们来看看闭包的用途。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。</p>
<p><strong>1. 匿名自执行函数</strong></p>
<p>我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//将全部li字体变为红色</div><div class="line">(function()&#123;    </div><div class="line">    var els = document.getElementsByTagName(&apos;li&apos;);</div><div class="line">    for(var i = 0,lng = els.length;i &lt; lng;i++)&#123;</div><div class="line">        els[i].style.color = &apos;red&apos;;</div><div class="line">    &#125;    </div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，<br>因此els,i,lng这些局部变量在执行完后很快就会被释放，节省内存！<br>关键是这种机制不会污染全局对象。</p>
<p><strong>2. 实现封装/模块化代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var person= function()&#123;    </div><div class="line">    //变量作用域为函数内部，外部无法访问    </div><div class="line">    var name = &quot;default&quot;;       </div><div class="line"></div><div class="line">    return &#123;    </div><div class="line">       getName : function()&#123;    </div><div class="line">           return name;    </div><div class="line">       &#125;,    </div><div class="line">       setName : function(newName)&#123;    </div><div class="line">           name = newName;    </div><div class="line">       &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125;();</div><div class="line">console.log(person.name);//直接访问，结果为undefined    </div><div class="line">console.log(person.getName());  //default </div><div class="line">person.setName(&quot;jozo&quot;);    </div><div class="line">console.log(person.getName());  //jozo</div></pre></td></tr></table></figure></p>
<p><strong>3. 实现面向对象中的对象</strong><br>这样不同的对象(类的实例)拥有独立的成员及状态，互不干涉。虽然JavaScript中没有类这样的机制，但是通过使用闭包，<br>我们可以模拟出这样的机制。还是以上边的例子来讲:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;    </div><div class="line">    var name = &quot;default&quot;;       </div><div class="line"></div><div class="line">    return &#123;    </div><div class="line">       getName : function()&#123;    </div><div class="line">           return name;    </div><div class="line">       &#125;,    </div><div class="line">       setName : function(newName)&#123;    </div><div class="line">           name = newName;    </div><div class="line">       &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125;;    </div><div class="line"></div><div class="line"></div><div class="line">var person1= Person();    </div><div class="line">print(person1.getName());    </div><div class="line">john.setName(&quot;person1&quot;);    </div><div class="line">print(person1.getName());  // person1  </div><div class="line"></div><div class="line">var person2= Person();    </div><div class="line">print(person2.getName());    </div><div class="line">jack.setName(&quot;erson2&quot;);    </div><div class="line">print(erson2.getName());  //person2</div></pre></td></tr></table></figure></p>
<p>Person的两个实例person1 和 person2 互不干扰！因为这两个实例对name这个成员的访问是独立的 。</p>
<p>##5. 内存泄露及解决方案<br><strong>垃圾回收机制</strong></p>
<p>说到内存管理，自然离不开JS中的垃圾回收机制，有两种策略来实现垃圾回收：标记清除 和 引用计数；</p>
<p><code>标记清除：</code>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。 2008年为止，IE，Firefox，opera，chrome，Safari的javascript都用使用了该方式；</p>
<p><code>引用计数：</code>跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个值的引用次数就是1，如果这个值再被赋值给另一个变量，则引用次数加1。相反，如果一个变量脱离了该值的引用，则该值引用次数减1，当次数为0时，就会等待垃圾收集器的回收。</p>
<p>这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。早期的IE版本里（ie4-ie6）采用是计数的垃圾回收机制，闭包导致内存泄露的一个原因就是这个算法的一个缺陷。</p>
<p>我们知道，IE中有一部分对象并不是原生额javascript对象，例如，BOM和DOM中的对象就是以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数。因此，虽然IE的javascript引擎采用的是标记清除策略，但是访问COM对象依然是基于引用计数的，因此只要在IE中设计COM对象就会存在循环引用的问题！</p>
<p><strong>举个栗子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">window.onload = function()&#123;</div><div class="line">    var el = document.getElementById(&quot;id&quot;);</div><div class="line">    el.onclick = function()&#123;</div><div class="line">        alert(el.id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码为什么会造成内存泄露？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">el.onclick= function () &#123;</div><div class="line">    alert(el.id);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收；</p>
<p>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.onload = function()&#123;</div><div class="line">    var el = document.getElementById(&quot;id&quot;);</div><div class="line">    var id = el.id; //解除循环引用</div><div class="line">    el.onclick = function()&#123;</div><div class="line">        alert(id); </div><div class="line">    &#125;</div><div class="line">    el = null; // 将闭包引用的外部函数中活动对象清除</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##6. 总结闭包的优缺点<br><strong>优点：</strong></p>
<ul>
<li>可以让一个变量常驻内存 (如果用的多了就成了缺点</li>
<li>避免全局变量的污染</li>
<li><p>私有化变量<br><strong>缺点</strong></p>
</li>
<li><p>因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存</p>
</li>
<li>引起内存泄露</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/26/JS-进阶-闭包，作用域链，垃圾回收，内存泄露/" class="archive-article-date">
  	<time datetime="2016-10-26T07:23:41.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-26</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-你不知道的JS（笔记4）-作用域与闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/你不知道的JS（笔记4）-作用域与闭包/">你不知道的JS（笔记4）--作用域与闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在讲解作用域闭包的内容之前，需要对以下概念有所掌握：</p>
<ol>
<li>JavaScript具有两种作用域：全局作用域和函数作用域，至于块作用域也不能说没有，比如说： try …catch…语句中，catch分句就是块作用域，还有with语句等。</li>
<li>ES6中的let关键字，可以用来在任意代码块中声明变量。</li>
<li>什么事立即执行函数表达式以及它的作用。</li>
</ol>
<h3 id="老生常谈什么是闭包"><a href="#老生常谈什么是闭包" class="headerlink" title="老生常谈什么是闭包"></a>老生常谈什么是闭包</h3><p>闭包的概念：<strong>函数可以记住并访问所在的词法作用域时，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    var a = 2;</div><div class="line">    function bar()&#123;</div><div class="line">        console.log(a);</div><div class="line">    &#125;</div><div class="line">    return bar;</div><div class="line">&#125;</div><div class="line">var baz = foo();</div><div class="line">baz(); //这就是闭包的效果</div></pre></td></tr></table></figure></p>
<p>函数bar()的词法作用域能够访问foo()的内部作用域，然后我们将bar()函数本身当作一个值进行传递。在foo()执行后，其返回值赋值给变量baz并调用baz()。<br>在foo()执行后，通常会期待foo()的整个内部作用于都被销毁，因为我们知道引擎有垃圾回收机制来释放不在使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。<br>但是，<strong>闭包的神奇之处在于可以阻止这件事情发生。事实上内部作用域依然存在，因此，没有被回收。</strong>那么是谁在使用这个内部作用域呢？当然是bar()在使用。<br>由于bar()声明在foo()函数内部，所以它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以便bar()在以后的任何时间进行引用。<br><strong>bar()函数在foo()调用完成后，依旧持有对其作用域的引用，而这个引用就叫做闭包</strong></p>
<p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处调用时都可以观察到闭包</p>
<p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处调用时都可以观察到闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    var a = 2;</div><div class="line">    function baz()&#123;</div><div class="line">        console.log(a)//2</div><div class="line">    &#125;</div><div class="line">    bar(baz);</div><div class="line">&#125;</div><div class="line">function bar(fn)&#123;</div><div class="line">    fn(); //这就是闭包</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相比于上面代码的枯燥，这有一个更加常见的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function wait(message)&#123;</div><div class="line">    setTimeout(function time()&#123;</div><div class="line">        console.log(message);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;</div><div class="line">wait(&quot;hello clousre&quot;);</div></pre></td></tr></table></figure></p>
<p>简单分析一下这段代码：我们将一个名为time的内部函数传递给setTimeout(),time具有涵盖wait()作用域的闭包，因此，还保有对变量message的引用。<br>wait(..)执行1000ms后，它的内部作用域并不会消失，time()函数依旧保有对wait()作用域的闭包，在引擎内部，内置的工具函数setTimeout()会持有一个对参数的引用，这个参数也许叫作fn或者func之类的。引擎会调用这个函数，而词法作用域在这个过程中保持完整。<br><strong>这就是闭包</strong><br>那么闭包有哪些应用呢？其实包括定时器，事件监听器，Ajax请求，跨窗口通信，Web Workers或者任何其他的异步(或者同步)任务中，<strong>只要使用回掉函数，实际上就是在使用闭包!</strong></p>
<p>这里我们再看一个特别典型闭包的例子，<strong>但严格来说它并不是闭包</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line">(function IIFE()&#123;</div><div class="line">    console.log(a)</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>IIFE即立即执行函数表达式，第一个（）让函数变为函数表达式，第二个（）函数执行。为什么说他严格上来讲并不是闭包呢？<strong>因为在示例代码中函数并不是在它本身的词法作用域之外执行的，它在其定义时所在的作用域执行，a是通过词法作用域查找到的，并不是闭包发现的。</strong><br>尽管IIFE本身并不是观察闭包的恰当例子，但他的确创建了一个封闭的作用域，并且也是最常用来创建被封闭起来的闭包的工具。</p>
<h2 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h2><p>说到闭包我们接触最早的也许就是for循环的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 1; i&lt;6; i++)&#123;</div><div class="line">    setTImeout(function time()&#123;</div><div class="line">        console.log(i)</div><div class="line">    &#125;, i*1000)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>记得第一次看见这段代码的时候，那是被深深的虐到，作为C语言起手的同学，当时真的是一脸的懵逼，为什么会输出5个6， 为什么会输出5个6，为什么？当时其他人的讲解也是模模糊糊的，虽然提出了解决方法，当还是无法理解这其中的机制原理，所以，我痛下决心把它弄懂！也许只有我不懂吧！</p>
<p>问：为什么会输出66666呢？<br>答：能输出66666说明for循环内部的代码的确执行了5次。<br>问：那6是从哪来的呢？<br>答：6是我们循环的终止条件，所以输出6。<br>问：那为什么不是循环一次，输出一个值， 1，2，3，4，5这样呢？<br>答：<strong>setTimeout()函数是在循环结束时执行的，</strong>就算是你设置setTimeout(fn, 0),它也是在for循环完成后立即执行，总之就是在for循环执行完成后才执行。</p>
<p>好了，这就不难理解了为什么会输出66666了。但这也就引出了一个更深入的话题，代码中到底什么缺陷导致它的行为同语义暗示的不一致呢？</p>
<p>缺陷是：<strong>我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。</strong>所以，实际的样子是这样。<br><img src="https://sfault-image.b0.upaiyun.com/125/327/1253275496-56f35051d7b1a" alt="全局作用域解析图"></p>
<p>而我们想象中的样子确是这样。<br><img src="https://sfault-image.b0.upaiyun.com/125/125/125125388-56f35061d9e46" alt=""></p>
<p>下面回到正题。既然明白了缺陷是什么，那么要怎样做才能达到我们想象中的样子呢？答案是我们需要在每一次迭代的过程中都创建一个闭包作用域。在上文中我们已经有所铺垫，IIFE会通过声明立即执行一个函数来创建作用域。so我们可以将代码改成下面的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i=1; i&lt;6; i++)&#123;</div><div class="line">    (function()&#123;</div><div class="line">        setTImeout(function time()&#123;</div><div class="line">            console.log(i)</div><div class="line">        &#125;, i*1000)</div><div class="line">    &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样每一次迭代我们都创建了一个封闭的作用域(你可以想象为上图中黄色的矩形部分)。但是这样做仍旧不行，为什么呢？<strong>因为虽然每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来，但我们封闭的作用域是空的，</strong>所以必须传点东西过去才能实现我们想要的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for(var i=1; i&lt;6; i++)&#123;</div><div class="line">    (function()&#123;</div><div class="line">        var j = i</div><div class="line">        setTImeout(function time()&#123;</div><div class="line">            console.log(j)</div><div class="line">        &#125;, j*1000)</div><div class="line">    &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ok!试试现在他能正常工作吗？对这段代码再进行一点改进<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i=1; i&lt;6; i++)&#123;</div><div class="line">    (function(j)&#123;</div><div class="line">        setTImeout(function time()&#123;</div><div class="line">            console.log(j)</div><div class="line">        &#125;, j*1000)</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总的来说，就是在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数可以将新的作用域封闭在每个迭代内部，我们同时在迭代的过程中将每次迭代的i值作为参数传入进新的作用域，这样在迭代中创建的封闭作用域就都会含有一个具有正确值的变量供我们访问。ok,it’s work!</p>
<h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>仔细思考我们前面的解决方案。我们使用IIFE在每次迭代时都创建一个新的作用域。也就是说，每次迭代我们都需要一个块作用域。前面我们提到，你需要对ES6中的let关键字进行了解，它可以用来劫持块作用域，并且在这个块作用域中声明一个变量。</p>
<p><em>本质上来讲它是将一个块转换成可以被关闭的作用域。</em><br><figure class="highlight m"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for(var i<span class="built_in">=</span><span class="number">1</span>; i&lt;<span class="number">6</span>; i++)&#123;</div><div class="line">        let j <span class="built_in">=</span> i; //闭包的块作用域</div><div class="line">        setTImeout(function time()&#123;</div><div class="line">            console.log(j)</div><div class="line">        &#125;, j*<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果将let声明在for循环的头部那么将会有一些特殊的行为，有多特殊呢？<em>它会指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</em>不管这句话有多拗口，看看代码吧!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(let i=1; i&lt;6; i++)&#123;</div><div class="line">        setTImeout(function time()&#123;</div><div class="line">            console.log(i)</div><div class="line">        &#125;, i*1000)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好的本节到这，再会！！</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/24/你不知道的JS（笔记4）-作用域与闭包/" class="archive-article-date">
  	<time datetime="2016-10-24T05:29:06.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-你不知道的JS（笔记3）-this解析2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/你不知道的JS（笔记3）-this解析2/">你不知道的JS（笔记3）--this解析2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上一节中”你不知道的JS –this解析1”介绍了this的两种绑定方式，<code>默认绑定</code>和<code>隐式绑定</code>，在这一节继续介绍this的另两种绑定方式<code>显示绑定</code>和<code>new绑定</code>。那么，我们要解决的问题是上节提到的：this丢失！</p>
<h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>在隐式绑定中，我们必须在一个对象的内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接绑定到这个对象上，那么如果我们不想在每个对象内部包含函数引用，而想在每个对象上强制调用函数，该怎么做呢？<br>这时就需要 call(绑定this, 其他参数…)和apply(绑定this, 其他参数…)方法出场了，这两个方法的第一个参数都是给this准备的，不同之处在于其他参数的形式上，他们两的其他参数对比如下：</p>
<blockquote>
<p>call(绑定this, “参数1”，”参数2”，”参数3”，”参数4”)；<br>apply(绑定this, [“参数1”，”参数2”，”参数3”，”参数4”]);</p>
</blockquote>
<p>apply的其他参数是以数组序列形式存在的，它会在执行时将其解析成单个的参数再依次的传递到调用的函数中，这有什么用处呢？加入我们有一个数组</p>
<blockquote>
<p>var arr = [1,2,3,4,5,6];</p>
</blockquote>
<p>现在我要找到其中的最大值，当然这里有很多方法了。既然这里讲到apply那么我们就用apply方法来解决这个问题。如果想要找到一组数中最大的一个，有一个简单的方法,使用Math.max(…)。但是，该方法并不能找出一个数组中的最大值，也就是说：</p>
<blockquote>
<p>Math.max(1,2,3,4,5); // 可以找到最大值5<br>Math.max([1,2,3,4,5]); // 这就不行了，因为不接受以数组作为参数</p>
</blockquote>
<p>我们的做法就是通过：</p>
<blockquote>
<p>Math.max.apply(null, [1,2,3,4,5]); //得到数组中的最大值5</p>
</blockquote>
<p>还有很多其他方面的用处，比如push等等，似乎有点跑题了！！！不过我想说的就是通过call()和apply()这两种方法我们可以显式的绑定this到指定的对象！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a: 2</div><div class="line">&#125;</div><div class="line">foo.call(obj);//2</div></pre></td></tr></table></figure>
<p>但是，显式绑定仍旧无法解决this丢失绑定的问题。</p>
<h2 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h2><p>显式绑定的一个变种可以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">        a: 2</div><div class="line">     &#125;</div><div class="line">var bar = function()&#123;</div><div class="line">    foo.call(obj);</div><div class="line">&#125;</div><div class="line">bar();// 2</div><div class="line">setTimeout(bar, 100); // 2</div><div class="line">bar.call(window); // 2</div></pre></td></tr></table></figure>
<p>看看它是如何工作的：我们创建了一个函数bar(),并在他的内部手动调用foo.call(obj)。因此，强制把foo的this绑定到了obj，无论之后如何调用函数bar，它总会手动在obj上调用foo。这样的形式我们称之为<code>硬绑定</code>。<br>硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo(something)&#123;</div><div class="line">    console,log(this.a, something);</div><div class="line">    return this.a + something;</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a: 2</div><div class="line">&#125;</div><div class="line">var bar = function()&#123;</div><div class="line">    return foo.apply(obj, arguments);</div><div class="line">&#125;</div><div class="line">var b = bar(3); //2, 3</div><div class="line">console.log(b); //5</div></pre></td></tr></table></figure>
<p>另一个常用的方法是创建一个可以重复使用的辅助函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo(something)&#123;</div><div class="line">    console,log(this.a, something);</div><div class="line">    return this.a + something;</div><div class="line">&#125;</div><div class="line">//简单的辅助函数</div><div class="line">function bind(fn, obj)&#123;</div><div class="line">    return function()&#123;</div><div class="line">        return fn.apply(obj, arguments);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a:2</div><div class="line">&#125;</div><div class="line"></div><div class="line">var bar = bind(foo, obj);</div><div class="line"></div><div class="line">var b = bar(); //2, 3</div><div class="line">console.log(b); //5</div></pre></td></tr></table></figure>
<p>硬绑定是一种非常常用的模式，所以ES5提供了内置的方法Function.prototype.bind,它的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(something)&#123;</div><div class="line">    console,log(this.a, something);</div><div class="line">        return this.a + something;</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a:2</div><div class="line">&#125;</div><div class="line">var bar = foo.bind(obj);</div><div class="line">var b = bar(3); //2, 3</div><div class="line">console.log(b); //5</div></pre></td></tr></table></figure>
<p>bind(…)会返回一个硬编码的心函数，它会把指定的参数设置为this的上下文并调用原始函数。</p>
<h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>第四条规则，也是最后一条规则，在讲解他之前我们首先要澄清一个非常常见的关于javascript中函数和对象的误解。在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用new初始化类是会调用类中的构造函数。通常的形式是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someThinges = new MyClass(...)</div></pre></td></tr></table></figure>
<p>javascript中也有个new操作符，但javascript中的new操作符的机制与面向类的语言完全不同。首先我们重新定义一下JavaScrit中的“构造函数”。在Javascript中，构造函数只是一些使用new操作符时被调用的函数。它并不会属于某个类，也不会实例化一个类。实际上它甚至都不能说是一种特殊的函数类型，它们只是被new操作符调用的普通函数而已。举例来说，思考一下Number()作为构造函数时的行为，ES5.1中这样描述它</p>
<blockquote>
<p><code>Number</code>构造函数<br>当<code>Number</code>在<code>new</code>表达式中被调用时，它是一个构造函数：它会初始化新建的对象。</p>
</blockquote>
<p>所以，包括内置对象函数在内的所有函数都可以用new来调用，这种函数被称为构造函数调用，这有个非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用new来调用函数，会自动执行下面的操作：</p>
<ol>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行[[prototype]]连接（之后会细说）</li>
<li>这个新对象会绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数会自动返回这个对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(a)&#123;</div><div class="line">    this.a = a</div><div class="line">&#125;</div><div class="line"></div><div class="line">var bar = new foo(2);</div><div class="line">console.log(bar) // foo &#123;a: 2&#125;</div><div class="line">console.log(bar.a); //2</div></pre></td></tr></table></figure>
<p>使用new 来调用foo(…)时，我们会构造一个新的对象，并把它绑定到foo(…)调用中的this上。new是最后一种可以影响函数调用时this绑定行为的方法。我们称之为new绑定。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>我们之前介绍的四条规则已经可以包含所有正常使用函数。但是在ES6中介绍了一种无法使用这些规则的特殊函数类型：箭头函数<br>箭头函数不是使用function关键字定义的，而是使用“ =&gt; ”定义。<code>箭头函数不使用this的四种标准规则，而是根据外层作用域(函数或全局)来决定this。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    //返回一个箭头函数</div><div class="line">    return (a) =&gt;&#123;</div><div class="line">        //this继承自foo()</div><div class="line">        console.log(this.a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var obj1 = &#123;</div><div class="line">    a: 2</div><div class="line">&#125;</div><div class="line">var obj2 = &#123;</div><div class="line">    a: 3</div><div class="line">&#125;</div><div class="line">var bar = foo.call(obj1);</div><div class="line">bar.call(obj2); //2  不是3</div></pre></td></tr></table></figure>
<p>foo()内部创建的箭头函数会捕获调用时foo()的this,由于foo()的this绑定到obj1，bar的this也会绑定到obj1上，而且箭头函数的绑定无法被修改！箭头函数最常用与回调函数中，例如事件处理器或者定时器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    setTimeout(()=&gt;&#123;</div><div class="line">        //这里的this在词法上继承自foo()，也就是说只要foo()绑定到了obj1上，箭头函数的this也就绑定到了obj1上</div><div class="line">        console.log(this.a)</div><div class="line">    &#125;,100)</div><div class="line">&#125;</div><div class="line">var obj1 = &#123;</div><div class="line">        a: 2</div><div class="line">    &#125;</div><div class="line">foo.call(obj1); //2</div></pre></td></tr></table></figure>
<p>箭头函数可以像bind(..)一样确保函数的this被绑定到指定的对象，此外，其重要性还体现在他用更常见的词法作用域取代了传统的this机制。实际上在，ES6之前我们就已经使了用一种几乎和箭头函数完全一样的模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    console.log(this); //Object &#123;a: 2&#125;</div><div class="line"></div><div class="line">    var self = this; //词法作用域捕获this</div><div class="line"></div><div class="line">    setTimeout(function()&#123;</div><div class="line">    console.log(this); // Window &#123;external: Object, chrome: Object, document: document, obj1: Object, obj2: Object…&#125;</div><div class="line"></div><div class="line">   console.log(self.a);</div><div class="line">    &#125;, 100);</div><div class="line">&#125;</div><div class="line">var obj1 = &#123;</div><div class="line">            a: 2</div><div class="line">        &#125;</div><div class="line">foo.call(obj1); //2</div></pre></td></tr></table></figure>
<p>我分别在这段代码中foo()的内部，和setTimeout()的内部加了两行代码console.log(this)，当调用foo()函数并将其this绑定到obj1上时(即执行foo.call(obj1))，foo()内的this此时是Object {a: 2}，说明foo()函数中的this已经绑定到了obj1上，setTimeout()内的结果是Window…,如果你看了上一节《this全面解析（一）》的内容应该会很好理解，因为在setTimeout()方法中，函数传参相当于隐式赋值，调用方式自然运用默认规则，setTimeout()方法中函数的this指向window。为了让我们得到预期的结果，我们将foo()中的this保存下来(即var self = this),然后通过词法作用域的在setTimeout()方法中的函数中引用self变量。读者可以自行测试，如果不这样做得出的结果会是什么(undifined吗？自行验证一下吧！）<br>好吧！一不小心又啰嗦的讲了这么多。虽然，self = this和箭头函数看起来都可以取代bind(),但本质上来说，他们想取代的是this机制。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到后就可以顺序应用下面这四条规则来判断this的绑定对象</p>
<ol>
<li>是否由new调用？绑定到新创建的对象</li>
<li>是否由call()或apply()调用？绑定到指定的对象</li>
<li>是否由上下文对象调用？绑定到那个上下文对象</li>
<li>默认：严格模式undifined，非严格绑定到全局对象<br>ES6中的箭头函数不会使用四条标准的绑定规则，而是根据词法作用域来决定this,具体来说，箭头函数会继承外层函数调用的this绑定(无论this绑定到了什么)，这其实和ES6之前代码中的self = this 机制一样</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/24/你不知道的JS（笔记3）-this解析2/" class="archive-article-date">
  	<time datetime="2016-10-24T02:35:44.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-你不知道的JS（笔记2）-this解析1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/22/你不知道的JS（笔记2）-this解析1/">你不知道的JS（笔记2）--this解析1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <em>你不知道的JS（笔记1）– this的初探</em> 中我们排除了对于this的错误理解，并且明白了每个函数的this是在调用时绑定的，完全取决于函数的调用位置。在本节中我们主要介绍一下几个主要内容：</p>
<ol>
<li>什么是调用位置</li>
<li>绑定的规则</li>
<li>this此法</li>
</ol>
<h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p><strong>调用位置</strong>:就是函数在代码中被调用的位置(而不是声明位置)。要想回答this到底引用的是什么？只有仔细分析调用位置才能回答这个问题。<br>而分析调用位置最重要的就是分析<code>调用栈</code>。下面是调用栈的定义。</p>
<p><strong>调用栈</strong>：就是为了达到当前执行位置所调用的所有函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function baz()&#123;</div><div class="line">     //当前调用栈是：baz</div><div class="line">     //因此，当前调用位置是全局作用域</div><div class="line">     console.log(&quot;baz&quot;);</div><div class="line">     bar(); //bar的调用位置</div><div class="line">&#125;</div><div class="line">function bar()&#123;</div><div class="line">     //当前调用栈是：baz -&gt; bar</div><div class="line">     //因此，当前调用位置是在baz中</div><div class="line">     console.log(&quot;bar&quot;);</div><div class="line">     foo(); //foo的调用位置</div><div class="line">&#125;</div><div class="line">function foo()&#123;</div><div class="line">     //当前调用栈是：baz -&gt; bar -&gt; foo</div><div class="line">     //因此，当前调用位置是在baz中</div><div class="line">     console.log(&quot;foo&quot;);</div><div class="line">&#125;</div><div class="line">baz(); // baz的调用位置</div></pre></td></tr></table></figure>
<h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>我们的思路是，通过找到函数的调用位置，然后判断需要应用规则中的哪一条。便可决定this的绑定对象。关于this的绑定规则主要是以下四种：</p>
<ol>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定</li>
<li>new绑定</li>
</ol>
<h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h3><p>默认绑定的典型类型是：独立函数调用。 思考如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo ()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo();  // 2</div></pre></td></tr></table></figure></p>
<p>调用foo()时，函数应用了默认绑定，this只想全局对象window(这是在非严格模式下，若是在严格模式下会报错)，所以this.a被解析成了全局变量a。所以，在不使用任何修饰的函数引用进行调用，只能使用默认绑定，无法应用其他规则。</p>
<h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2.隐式绑定"></a>2.隐式绑定</h3><p>隐式绑定的常见形式是在调用位置具有上下文对象，或者说被某个对象拥有或者包含。看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    console.log(this.a);</div><div class="line"> &#125;</div><div class="line"> var obj = &#123;</div><div class="line">      a: 2,</div><div class="line">      foo: foo</div><div class="line"> &#125;;</div><div class="line"> obj.foo(); // 2</div></pre></td></tr></table></figure></p>
<p>这里函数foo()是预先定义好的，然后再将其添加为obj对象的引用属性。调用位置使用obj上下文来引用函数，因此可以说函数被调用时obj对象“拥有”或者“包含”它。无论你如何称呼这个模式，当foo()被调用时，它的前面确实是加上了obj的引用。当函数引用上下文对象时，隐式绑定规则就会把函数调用中的this绑定到这个上下文对象。所以，this.a和obj.a是一样的。</p>
<p>另一个需要注意的点是：<em>对象属性引用链中只有最后一层在调用位置起作用</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">     console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj2 = &#123;</div><div class="line">     a: 100,</div><div class="line">     foo: foo</div><div class="line">&#125;;</div><div class="line">var obj1 = &#123;</div><div class="line">     a: 1,</div><div class="line">     obj2: obj2</div><div class="line">&#125;</div><div class="line">obj1.obj2.foo(); // 100</div></pre></td></tr></table></figure>
<p>隐式绑定一个最常见的问题</p>
<p>一个最常见的问题就是：<em>隐式绑定的函数会丢失绑定对象</em>。也就是是说它会应用<code>默认绑定</code>，而把this绑定到全局对象或者undifined上，取决于是否是严格模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj =&#123;</div><div class="line">    a: 2,</div><div class="line">    foo: foo</div><div class="line">&#125;</div><div class="line">var bar = obj.foo; //函数别名</div><div class="line">var a = &quot;global&quot;;</div><div class="line">bar(); // &quot;global&quot;</div></pre></td></tr></table></figure>
<p>虽然bar是obj.foo的一个引用，但实际上，他引用的是foo函数本身， 因此， 此时的bar()其实是一个不带任何修饰的函数调用，因此，它应用了<code>默认绑定</code>。<br><em>一种更微妙，更常见的并且更出乎意料的情况发生在传入回调函数时：</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    console.log(this.a);</div><div class="line">&#125;</div><div class="line">function callBack(fn)&#123;</div><div class="line">    fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">    a: 2,</div><div class="line">    foo: foo</div><div class="line">&#125;</div><div class="line">var a = &quot;global&quot;;</div><div class="line">callBack(obj.foo); // &quot;global&quot;</div></pre></td></tr></table></figure>
<p><em>参数传递其实就是一种隐式赋值</em>，这句话我们可以用下面的两段代码来详细的讲解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    var a = 1;</div><div class="line">    function fn()&#123;</div><div class="line">        alert(a); //1</div><div class="line">        a = 2;</div><div class="line">    &#125;</div><div class="line">    fn();</div><div class="line">    alert(a); // 2</div><div class="line"></div><div class="line">_ _ _</div><div class="line"></div><div class="line">    var a = 1;</div><div class="line">    function fn(a)&#123;</div><div class="line">          alert(a); //undifined</div><div class="line">          a = 2;</div><div class="line">    &#125;</div><div class="line">    fn();</div><div class="line">    alert(a); // 1</div></pre></td></tr></table></figure>
<p>思考一下结果是否与你想象的一致呢？<br><em>在第一段代码中：</em><br>首先，在全局作用域中，先通过变量提升，找到了标识符a和函数fn，a此时有个默认值为undifined。然后，在执行阶段我们先将变量a赋值为1，紧跟着函数fn()执行。此时，在函数域中，依旧应用变量提升的规则，但是什么都没找到，接着执行函数内的代码:alert(a),因为在函数中并没有找到变量a。所以，通过作用域链向上层的父级作用域中查找，我们找到了a,并且此时a的值已经被赋值为1，所以，alert(a)这句的结果就是1。下一句代码：a = 2,注意a的前面没有关键字var, 即这里的a是全局的，也就是说在执行这句代码时，他修改了全局作用域中a的值，即a现在为2。最后在执行alert(a)时，自然而然a的值便是2了。</p>
<p><em>在第二段代码中：</em><br>同样，通过变量提升，我们找到了标识符a和函数fn，a此时的默认值也为undifined。开始执行，a首先被赋值为1。然后，函数执行，这里与第一段代码的不同之处在于，在函数fn中传入了参数a,那么这么做的结果就是：在函数域先运用变量提升的规则，不会像第一段代码中那样什么都找不到，而是相当于定义了一个值为undifined（调用的时候没有传入参数）的变量a,所以当执行函数域中的alert(a)时，结果就为undifined，而不会通过作用域链向上去查找，因为本函数中已经找到了，只不过是以参数的形式传入的。同理代码(a = 2)会修改a的值，即在函数域中，a的值现在为2（读者可以去尝试在函数中最后面alert一下a的值）。而在函数外执行alert(a),我们得到的结果便是1，因为该句代码是在全局中执行的，即会在全局中去查找变量a,而不会去访问函数域中的a。这也是因为，在JavaSceipt中<code>子作用域</code>可以访问<code>父作用域</code>而反过来却不行的规则。</p>
<p>回到我们this绑定丢失的话题上，说了这么多，我其实就是想说：<em>参数传递其实就是一种隐式赋值.</em><br>我们按照上面的方式来解析代码：<em>在执行callBack(obj.foo)时，在函数作用域通过变量提升找到了参数fn,它的默认值为undifined，然后我们将参数传入，其实相当于(var fn = obj.foo),这就与前面的将其直接赋值给一个变量对等上了，然后再执行fn()，应用默认绑定，此时的this已经不指向obj了，而是指向window(严格模式)。</em></p>
<p>如果把函数传入内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">    console.log(this.a)</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    a: 2,</div><div class="line">    foo: foo</div><div class="line">&#125;</div><div class="line">var a = &quot;global&quot;;</div><div class="line">setTimeout(obj.foo, 1000); //&quot;global&quot;</div></pre></td></tr></table></figure>
<p>JavaSceipt环境中内置的setTimeout()函数实现和下面的伪代码类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function setTimeout(fn, delay)&#123;</div><div class="line">    //等待delay秒</div><div class="line">    fn(); //调用位置</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就向你们看到的那样，回调函数丢失this绑定的情况是非常常见的，并且还有一种情况this的行为会出乎我们意料：调用回调函数的函数可能会修改this。由于无法控制回调函数的执行方式，因此就没有办法控制调用位置得到期望的绑定，下一节我们会介绍如何通过固定this来“修复“这个问题。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/22/你不知道的JS（笔记2）-this解析1/" class="archive-article-date">
  	<time datetime="2016-10-22T07:48:57.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-22</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-你不知道的JS（笔记1）-- this的初探" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/22/你不知道的JS（笔记1）-- this的初探/">你不知道的JS（笔记1）-- this的初探</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近，在看《你不知道的JS(上卷)》这本书，学下自己的笔记！！</p>
<p>this关键字是javascript最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有的函数作用域中。但是即使是非常有经验的javascript开发者也很难说出他到底指向什么。本节将分三个部分讲解javascript中的this：</p>
<ol>
<li>为什么要使用this</li>
<li>两种常见的对于this的误解</li>
<li>this到底是什么</li>
</ol>
<h2 id="一、为什么要使用this"><a href="#一、为什么要使用this" class="headerlink" title="一、为什么要使用this"></a>一、为什么要使用this</h2><p>在书中通过两段代码的对比来说明为什么要使用this。第一段代码如下：这段代码在不同的上下问对象(me和you)中重复使用函数identify()和speak(),不用针对不同的对象编写不同版本的函数。</p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function identify()&#123;</div><div class="line">    return this.name.toUpperCase();</div><div class="line">&#125;</div><div class="line">function speak()&#123;</div><div class="line">    var greeting = &quot;hello, I am &quot; + identify.call(this);</div><div class="line">    console.log(greeting);</div><div class="line">&#125;</div><div class="line">var me = &#123;</div><div class="line">    name: &quot;zhou&quot;</div><div class="line">&#125;</div><div class="line">var you = &#123;</div><div class="line">    name: &quot;reader&quot;</div><div class="line">&#125;</div><div class="line">identify.call(me); //ZHOU</div><div class="line">identify.call(you); //READER</div><div class="line">speak.call(me); // hello, I am ZHOU</div><div class="line">speak.call(you); // hello, I am READER</div></pre></td></tr></table></figure>
<h2 id="二、两种常见的对于this的误解"><a href="#二、两种常见的对于this的误解" class="headerlink" title="二、两种常见的对于this的误解"></a>二、两种常见的对于this的误解</h2><h3 id="误解1-指向函数自身"><a href="#误解1-指向函数自身" class="headerlink" title="误解1.指向函数自身"></a>误解1.指向函数自身</h3><p>常见的在函数内部引用自身的情况有：递归或者是一个在第一次被调用后自己接触绑定的事件处理器。 JavaScript的新手开发者(比如说我)通常认为：既然可以把函数看作一个对象，那就可以在调用函数时存储状态(属性的值)。<br>现在我们来分析这个模式，让大家看到this并不像所想的那样指向函数本身。下面这段代码，我们想要记录函数foo被调用的次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo(num)&#123;</div><div class="line">      console.log(&quot;foo: &quot; + num);</div><div class="line">      this.count++; //记录foo被调用的次数</div><div class="line">  &#125;</div><div class="line">  foo.count = 0;</div><div class="line">  for(var i=0; i&lt;10; i++)&#123;</div><div class="line">      if(i &gt; 5)&#123;</div><div class="line">          foo(i)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">   // foo: 6</div><div class="line">   // foo: 7</div><div class="line">   // foo: 8</div><div class="line">   // foo: 9</div><div class="line">  console.log(foo.count); // 0  为什么会是0呢?</div></pre></td></tr></table></figure>
<p>foo()函数中的console.log语句产生了4条输出，证明foo()确实被调用了4次，但foo.count仍然是0，所以，仅从字面上来理解，this指向函数自身是错误的。那么，问题的原因是什么呢？<br><strong>foo()函数是在全局作用域下执行的，this在这段代码中其实指向window，并且这段代码在无意中创建了一个全局变量count,他的值为NaN。</strong></p>
<h4 id="方法一-运用作用域-词法作用域-方法，该方法解决了我们遇到的问题，但是却没有直面this。"><a href="#方法一-运用作用域-词法作用域-方法，该方法解决了我们遇到的问题，但是却没有直面this。" class="headerlink" title="方法一 运用作用域(词法作用域)方法，该方法解决了我们遇到的问题，但是却没有直面this。"></a>方法一 运用作用域(词法作用域)方法，该方法解决了我们遇到的问题，但是却没有直面this。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo(num)&#123;</div><div class="line">    console.log(&quot;foo: &quot; + num);</div><div class="line">    data.count++; //记录foo被调用的次数</div><div class="line">&#125;</div><div class="line">var data =&#123;</div><div class="line"> count: 0</div><div class="line">&#125;;</div><div class="line"></div><div class="line">for(var i=0; i&lt;10; i++)&#123;</div><div class="line">    if(i &gt; 5)&#123;</div><div class="line">        foo(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> // foo: 6</div><div class="line"> // foo: 7</div><div class="line"> // foo: 8</div><div class="line"> // foo: 9</div><div class="line">console.log(data.count);// 4</div></pre></td></tr></table></figure>
<h4 id="方法二-创建一个指向函数对象的词法标识符-变量-来引用它。同样该方法仍旧回避了this的问题。"><a href="#方法二-创建一个指向函数对象的词法标识符-变量-来引用它。同样该方法仍旧回避了this的问题。" class="headerlink" title="方法二 创建一个指向函数对象的词法标识符(变量)来引用它。同样该方法仍旧回避了this的问题。"></a>方法二 创建一个指向函数对象的词法标识符(变量)来引用它。同样该方法仍旧回避了this的问题。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo(num)&#123;</div><div class="line">    console.log(&quot;foo: &quot; + num);</div><div class="line">    foo.count++; // foo指向它自身</div><div class="line">&#125;</div><div class="line">foo.count = 0;</div><div class="line">for(var i=0; i&lt;10; i++)&#123;</div><div class="line">    if(i &gt; 5)&#123;</div><div class="line">        foo(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> // foo: 6</div><div class="line"> // foo: 7</div><div class="line"> // foo: 8</div><div class="line"> // foo: 9</div><div class="line">console.log(foo.count);// 4</div></pre></td></tr></table></figure>
<h3 id="方法三-既然我们知道this在foo函数执行时指向了别处，那么我们需要做的就是强制this指向foo函数"><a href="#方法三-既然我们知道this在foo函数执行时指向了别处，那么我们需要做的就是强制this指向foo函数" class="headerlink" title="方法三 既然我们知道this在foo函数执行时指向了别处，那么我们需要做的就是强制this指向foo函数."></a>方法三 既然我们知道this在foo函数执行时指向了别处，那么我们需要做的就是强制this指向foo函数.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo(num)&#123;</div><div class="line">    console.log(&quot;foo: &quot; + num);</div><div class="line">    this.count++;</div><div class="line">&#125;</div><div class="line">foo.count = 0;</div><div class="line">for(var i=0; i&lt;10; i++)&#123;</div><div class="line">    if(i &gt; 5)&#123;</div><div class="line">        foo.call(foo, i); //使用call()可以确保this指向函数本身</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> // foo: 6</div><div class="line"> // foo: 7</div><div class="line"> // foo: 8</div><div class="line"> // foo: 9</div><div class="line">console.log(foo.count);// 4</div></pre></td></tr></table></figure>
<p><strong> 这次我们重this角度解决了问题 </strong></p>
<h2 id="误解2-指向函数作用域"><a href="#误解2-指向函数作用域" class="headerlink" title="误解2.指向函数作用域"></a>误解2.指向函数作用域</h2><p>第二种常见的误解是：this指向函数作用域。这个问题有点复杂，因为在某种情况下它是正确的，但在其他情况下他却是错误的。<br>但一定要明白，this在任何情况下都不指向函数的作用域，在javascript内部作用域和对象确实很相似，可见的标识符都是他的属性，但作用域“对象”无法通过JavaScript代码访问，它存在于JavaScript引擎内部<br>在文中给出了这样一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">     var a = 2;</div><div class="line">     this.bar();</div><div class="line">&#125;</div><div class="line">function bar()&#123;</div><div class="line">    console.log(this.a);</div><div class="line">&#125;</div><div class="line">foo(); // ReferenceError: a is not defined</div></pre></td></tr></table></figure>
<p>这段代码试图通过this联通foo()和bar()的词法作用域，从而让bar()可以访问foo()作用域的变量a。</p>
<h2 id="三、this到底是个什么玩意？"><a href="#三、this到底是个什么玩意？" class="headerlink" title="三、this到底是个什么玩意？"></a>三、this到底是个什么玩意？</h2><p>通过排除以上种种的误解，我们可以得出以下结论：</p>
<ul>
<li><strong>this是在运行时进行绑定的，并不是在编写时绑定的。</strong></li>
<li><p><strong>this的绑定和函数声明的位置没有关系，只取决于函数的调用方式。</strong></p>
<p>具体细节是：当一个函数被调用时，会创建一个活动记录(也称执行上下文(context))。这个记录会包含一些信息，比如： <strong>函数在哪里被调用(调用栈)， 函数的调用方式， 传入的参数等，而this就是这个记录的一个属性</strong>，会在函数执行过程中被用到。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2></li>
</ul>
<ol>
<li>随着你使用的模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱。因此，通过使用this隐式传递可以将API设计的更加简洁并且易于复用。</li>
<li>this既不指向函数自身，也不指向函数的作用域。</li>
<li>this实际上是函数被调用时发生的绑定，它的指向完全取决于函数在哪里被调用.</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/22/你不知道的JS（笔记1）-- this的初探/" class="archive-article-date">
  	<time datetime="2016-10-22T05:45:16.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-22</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JavaScript_Promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/21/JavaScript_Promise/">JavaScript Promise迷你书(后感)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近，在看《JavaScript Promise迷你书》这本书，从中学了好多，受益匪浅，希望坚持到底！！</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/21/JavaScript_Promise/" class="archive-article-date">
  	<time datetime="2016-10-21T02:59:15.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-hello" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/20/hello/">hello</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hello 这是我的第一篇博客，没写什么内容，但心情还是比较激动的，祝：接下来在工作和学习上可以试试顺利！！</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/20/hello/" class="archive-article-date">
  	<time datetime="2016-10-20T06:40:15.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/20/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/20/hello-world/" class="archive-article-date">
  	<time datetime="2016-10-19T16:04:45.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 ZhengJX
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Javascript/" style="font-size: 20px;">Javascript</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://segmentfault.com/">Segmentfault</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.ruanyifeng.com/blog//">阮一峰博客</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.mozilla.org/zh-CN/">Mozilla开发者网络</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.awesomes.cn/">Awesomes</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>