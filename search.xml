<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2016年终总结]]></title>
    <url>%2F2016%2F12%2F31%2F2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第一次写年终总结，对自己这一年里的付出和收获做一次记录。 回顾2016：这一年里，开启了许多人生的第一次！这一年，第一次来带了北京。第一次，看到了雪，也第一次感受了雾霾，第一次，出国旅游，也第一次知道了学好英语的重要性；有收获，有遗憾！这一年，大部分时间都在北京度过；见识了繁华的市区，和广阔的郊外；北京–远比我想象中的大！可以说，这是我人生中收获的一年，从迷茫的应届生，到小码农；期间付出了很多，走了不少弯路，还好，我没放弃！有了自己的目标，当个有出息的程序员；改掉懒惰和拖延，培养起了自己的学习习惯；在工作中得到了技能的提升；失去了陪伴家人的机会，16年没回家过春节；没去长城，故宫等景点走走，自己太宅了。 北京，这座经济快速发展的古城，见识了在现代高新科技气息下，透露出点传统文化韵味；奇妙但不新奇； 开始了规划自己的生活和工作！懂得重要的事情，一定要事先做好准备，最好有本子记录下时间，做好规划；每天给自己定个目标计划，几天看做完哪些事情，哪些先做等；定期看一本书，技术类或自传类；保持学习的心态，多看外文的技术类社区和视频；要对英语保持兴趣，不懂得的单词立即翻译； 展望2017：提高自己的英语水平，出国旅游一次；工作中得到更好的提升；家人平安，美满！]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写ReactMarkDown组件笔记]]></title>
    <url>%2F2016%2F11%2F17%2F%E7%BC%96%E5%86%99ReactMarkDown%E7%BB%84%E4%BB%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[编写自己的react组件 这一段时间因为项目需求，要编写自己的reactMarkdown，用于公司的项目中，在网上搜索了一些资料，决定以‘react-markdown’这个开源的组件为参考。好了，废话不多说，先开始准备工作吧； 搭开发发环境首先，我想打个能够热更新的开发环境，以express,webpack2,react-hot-loader等技术栈为主，参考了react-hot-loader-3-express-example这个开源的案例； 配置代码约束我用的是sublime text3，这款编辑器，要在sublime中安装SublimeLinter查看！ 注意：需要node的运行环境，要安装nodejs，要通过下载安装包在本地安装node，通过npm来安装node版本没效果！！ 接下来是配置.eslintrc.js这个配置文件，一下是个人的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889module.exports = &#123; "parser": 'babel-eslint', "env": &#123; "browser": true, "commonjs": true, "es6": true, 'node': true, 'jquery': true &#125;, 'extends': 'airbnb', 'parserOptions': &#123; 'sourceType': 'module' &#125;, "parserOptions": &#123; "ecmaFeatures": &#123; "experimentalObjectRestSpread": true, "jsx": true &#125;, "sourceType": "module" &#125;, "plugins": [ "react" ], 'rules': &#123; 'strict': 'off', 'indent': ['error', 2, &#123;'SwitchCase': 1&#125;], 'array-bracket-spacing': ['error', 'never'], 'block-spacing': ['error', 'never'], 'comma-dangle': ['error', 'never'], 'computed-property-spacing': ['error', 'never'], 'constructor-super': 'error', 'func-names': 'off', 'id-length': 'off', 'quotes': ['warn', 'single' ], 'jsx-quotes': ['error', 'prefer-double'], 'linebreak-style': ['warn', 'unix'], 'new-cap': ['error', &#123;'newIsCap': true, 'capIsNew': false&#125;], 'no-case-declarations': 'error', 'no-class-assign': 'error', 'no-const-assign': 'error', 'no-console': ['warn', &#123; allow: ['info', 'warn', 'error'] &#125;], 'no-empty-pattern': 'error', 'no-dupe-class-members': 'error', 'no-nested-ternary': 'off', 'no-param-reassign': 'off', 'no-this-before-super': 'error', 'no-undefined': 'error', 'no-unused-expressions': 'off', 'no-useless-concat': 'error', 'no-var': 'error', 'object-curly-spacing': ['error', 'never'], 'object-shorthand': 'warn', 'prefer-arrow-callback': 'error', 'prefer-reflect': 'warn', 'prefer-spread': 'error', 'prefer-template': 'warn', 'require-yield': 'error', 'semi': ['warn', 'always'], 'spaced-comment': 'off', 'space-before-function-paren': ['error', "never"], 'keyword-spacing': ['warn', &#123;'before': true, 'after': true&#125;], 'space-in-parens': ['error', 'never'], 'vars-on-top': 'off', 'max-len': ['warn', 150], 'key-spacing': ['warn', &#123; 'beforeColon': false, 'afterColon': true &#125;], 'react/jsx-closing-bracket-location': ['warn', 'props-aligned'], 'react/jsx-curly-spacing': ['error', 'never'], 'react/jsx-handler-names': ['warn', &#123; 'eventHandlerPrefix': 'handle|toggle' &#125;], 'react/jsx-indent-props': ['error', 2], 'react/jsx-no-duplicate-props': 'error', 'react/jsx-quotes': 'off', 'react/jsx-no-bind': ['off'], 'react/no-direct-mutation-state': 'error', 'react/no-multi-comp': ['error', &#123;'ignoreStateless': true&#125;], 'react/prefer-es6-class': 'warn', 'react/prop-types': 'off', 'react/sort-comp': 'off' &#125;&#125;; 我的配置中使用到了babel-eslint，eslint-plugin-react，eslint-config-airbnb这些第三方库需要在项目中下载到依赖中。 这里需要说明下eslint-config-airbnb这个第三方库的作用就是把es6写法中在项目中出现的一个问题!!]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-箭头函数学习记]]></title>
    <url>%2F2016%2F11%2F01%2Fes6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JS中的箭头函数箭头函数在JS里并不算是个新鲜的玩意儿，一直以来，JS都支持--&gt;这样的箭头符号。很早的时候有些浏览器还不支持JS,当时的人们为了兼容这些浏览器，需要这样写JS:12345&lt;script language="javascript"&gt;&lt;-- alert('Joe');// --&gt;&lt;/script&gt; 这段代码在不支持JS的浏览器里会被解读成2个未知标签和一段html注释。在支持JS的浏览器里，JS引擎会把看成是单行注释的开始。需要说明的是，–&gt;仅仅是在一行的开头才能表示这一行是注释，其余情况–&gt;是一个操作符，表示goes to的含义。12345function countdown(n) &#123; while (n --&gt; 0) &#123; alert(n); &#125;&#125; 这段代码确实能够正常运行哦。当你给countdown函数传入一个大于0的参数时，这个循环能够一直运行，直到n变为0为止。此箭头非彼箭头，以上讲述的–&gt;并不是我们今天要讲的主角，大家权当拓展下JS知识，下面让我们进入正题。 特性介绍箭头函数是ES6新增的特性之一，它为JS这门语言提供了一种全新的书写函数的语法。1234567// ES5var double = nums.map(function (v) &#123; return 2 * n;&#125;);// ES6var double = nums.map(v =&gt; 2 * n); 箭头函数简化了原先的函数语法，不需要再写function，如果函数体只有一行代码的话连return都不用写，这个特性对于热衷于简化流程和工作的程序员来说相当对胃口。 使用箭头函数有几个注意点： ##函数体箭头函数支持两种模式的函数体写法，我们姑且叫他简洁函数体和块级函数体。1234// 简洁函数体var fn = x =&gt; x * x;// 块级函数体var fn = (x, y) =&gt; &#123;return x + y;&#125;; 简介函数体默认会把表达式的结果返回，块级函数体需要手动return。如果想要返回一个对象又想使用简洁函数体的话，需要这么写：12var fn = () =&gt; (&#123;&#125;);fn(); // &#123;&#125; 如果写成var fn = () =&gt; {};，那么执行fn()只能返回undefined。 this用function生成的函数会定义一个自己的this，而箭头函数没有自己的this，而是会和上一层的作用域共享this。123456789function Person() &#123; this.age = 0; var self = this; setTimeout(function () &#123; self.age++; console.log(self.age); &#125;, 1000);&#125;var p = new Person(); 这段代码里，setTimeout的参数function中需要操作外层的age属性，必须要把this赋值给self，然后通过self来获取到age 如果使用箭头函数则省事很多，代码如下：12345678function Person() &#123; this.age = 0; setTimeout(() =&gt; &#123; this.age++; console.log(this.age); &#125;, 1000);&#125;var p = new Person(); apply &amp; call由于箭头函数已经绑定了this的值，即使使用apply或者call也不能只能起到传参数的作用，并不能强行改变箭头函数里的this。123456789101112131415161718192021222324var adder = &#123; x: 1, add1: function (y) &#123; console.log(this.x) var fn = v =&gt; v + this.x; return fn(y); &#125;, add2: function (y) &#123; var fn = v =&gt; v + this.x; var whatever = &#123; x: 2 &#125;; return fn.call(whatever, y); &#125;, add3: function (y) &#123; var p = &#123; x: 30 &#125;; return this.add2.call(p, y) &#125;&#125;;console.log(adder.add1(1)); // 2console.log(adder.add2(1)); // 仍然是2console.log(adder.add3(10)); // 40 箭头函数会绑定自己外层的作用域中的this,如add3是让add2中的this绑定到p中，所以箭头函数就取得p中的x:30; arguments普通函数里arguments代表了调用时传入的参数，但是箭头函数不然，在箭头函数中无法使用arguments当然，ES6中也有办法可以让箭头函数像普通函数一样使用类似于arguments这样的类数组对象12var fn = (...rest) =&gt; rest[0];fn(2); // 2 ...rest也是ES6的一个新特性，之后会介绍。 不能被new箭头函数不能与new关键字一起使用，会报错1234var Fn = () =&gt; &#123; this.a = 1;&#125;;var f = new Fn(); // Error 使用场景在我看来，箭头函数几乎可以完全取代function，除非是函数需要进行递归或者需要可变的this对象，其他场景我认为都可以使用箭头函数。 参考资料 ES6 In Depth: Arrow functions Arrow functions]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6 箭头函数]]></title>
    <url>%2F2016%2F11%2F01%2Fes6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[定义定义一个箭头函数很简单，基本语法是： 1234([param] [, param]) =&gt; &#123; statements&#125;param =&gt; expression param是参数，根据参数个数的不同，分为几种情况：() =&gt; {…} // 零个参数用（）表示x =&gt; {…} // 一个参数可以省略（）；(x, y) =&gt; {…} // 多个数不能省略（）；当然，和普通函数一样，箭头函数也可以使用ES6新增的默认参数和剩余参数1234var func1 = (x = 1, y = 2) =&gt; x + y;func1() // 得到3var func2 = (x, ...args) =&gt; &#123;console.log(args)&#125;;func2(1,2,3); // 输出 [2,3]; 箭头函数允许多行语句或者单行表达式作为函数体。多行语句要用{}括起来；单行表达式不需要{}，并且作为函数返回值：1234x =&gt; &#123;return x * x&#125;; // 函数返回 x * xx =&gt; x * x; // 同上一行x =&gt; return x * x; // SyntaxError 报错，不能省略 &#123;&#125;x =&gt; &#123; x * x&#125;; // 合法，没有定义返回值，返回 undefined 箭头函数也是JS函数的一种，所以之前的instanceof和typeof依然可用：12345var func1 = () =&gt; &#123;&#125;;func1 instanceof Function; // truevar func2 = () =&gt; &#123;&#125;;typeof func2; // "function" 特性箭头函数内部没有 constructor 方法，也没有 prototype，所以不支持 new 操作。new (() =&gt; {}) 会触发 TypeError 报错。1new (() =&gt; &#123;&#125;) // Uncaught TypeError: () =&gt; &#123;&#125; is not a constructor(...) 箭头函数没有自己内部的 this 指针。在箭头函数中， this 指针是继承于其所在的作用域。(个人理解为箭头函数不具备函数作用域，相当于表达式，this即为箭头函数被调用时外层的this)12345678910var a = 1;var test = &#123; a: 100, c: function()&#123; console.log(this.a); &#125;, d: ()=&gt;&#123;console.log(this.a)&#125;&#125;test.c();//100test.d();//1]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ JS 进阶 ] 闭包，作用域链，垃圾回收，内存泄露]]></title>
    <url>%2F2016%2F10%2F26%2FJS-%E8%BF%9B%E9%98%B6-%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[关于闭包，最近查看了一些资料，看到有不错的文章，邪王一起学习！！ 1.什么是闭包？来看一些关于闭包的定义： 闭包是指有权访问另一个函数作用域中变量的函数 –《JS高级程序设计第三版》 p178 函数对象可以通过作用域链相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为 ‘闭包’ 。 –《JS权威指南》 p183 内部函数可以访问定义它们的外部函数的参数和变量(除了this和arguments)。 –《JS语言精粹》 p36 来个定义总结 可以访问外部函数作用域中变量的函数 被内部函数访问的外部函数的变量可以保存在外部函数作用域内而不被回收—这是核心，后面我们遇到闭包都要想到，我们要重点关注被闭包引用的这个变量。 来创建个简单的闭包 var say = sayName() ：返回了一个匿名的内部函数保存在变量say中，并且引用了外部函数的变量name，由于垃圾回收机制，sayName函数执行完毕后，变量name并没有被销毁。 say() ：执行返回的内部函数，依然能访问变量name,输出 ‘jozo’ . ##2. 闭包中的作用域链理解作用域链对理解闭包也很有帮助。 变量在作用域中的查找方式应该都很熟悉了，其实这就是顺着作用域链往上查找的。 当函数被调用时： 先创建一个执行环境(execution context),及相应的作用域链； 将arguments和其他命名参数的值添加到函数的活动对象(activation object)作用域链：当前函数的活动对象优先级最高，外部函数的活动对象次之，外部函数的外部函数的活动对象依次递减，直至作用域链的末端–全局作用域。优先级就是变量查找的先后顺序； 先来看个普通的作用域链：1234function sayName(name)&#123; return name;&#125;var say = sayName('jozo'); 这段代码包含两个作用域：a.全局作用域；b.sayName函数的作用域，也就是只有两个变量对象，当执行到对应的执行环境时，该变量对象会成为活动对象，并被推入到执行环境作用域链的前端，也就是成为优先级最高的那个。 看图说话：在创建sayName()函数时，会创建一个预先包含变量对象的作用域链，也就是图中索引为1的作用域链，并且被保存到内部的[[Scope]]属性中，当调用sayName()函数的时候，会创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起作用域链，此后，又有一个活动对象（图中索引为0）被创建，并被推入执行环境作用域链的前端。 一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域。但是，闭包的情况又有所不同 ： 再来看看看闭包的作用域链： 123456function sayName(name)&#123; return function()&#123; return name; &#125;&#125;var say = sayName('jozo'); 这个闭包实例比上一个例子多了一个匿名函数的作用域： 在匿名函数从sayName()函数中被返回后，它的作用域链被初始化为包含sayName()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在sayName()中定义的所有变量和参数，更为重要的是，sayName()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链依然在引用这个活动对象，换句话说，sayName()函数执行完后，其执行环境的作用域链会被销毁，但他的活动对象会留在内存中，知道匿名函数会销毁。这个也是后面要讲到的内存泄露的问题。 ##3. 闭包的实例实例1：实现累加123456789101112131415161718192021// 方式1var a = 0;var add = function()&#123; a++; console.log(a)&#125;add();add();//方式2 ：闭包var add = (function()&#123; var a = 0; return function()&#123; a++; console.log(a); &#125;&#125;)();console.log(a); //undefinedadd();add();相比之下方式2更加优雅，也减少全局变量，将变量私有化 实例2 ：给每个li添加点击事件12345678910111213var oli = document.getElementsByTagName('li');var i;for(i = 0;i &lt; 5;i++)&#123; oli[i].onclick = function()&#123; alert(i); &#125;&#125;console.log(i); // 5//执行匿名函数(function()&#123; alert(i); //5&#125;()); 上面是一个经典的例子，我们都知道执行结果是都弹出5，也知道可以用闭包解决这个问题，但是我刚开始始终不能明白为什么每次弹出都是5，为什么闭包可以解决这问题。后来捋一捋还是把它弄清晰了： a. 先来分析没用闭包前的情况：for循环中,我们给每个li点击事件绑定了一个匿名函数，匿名函数中返回了变量i的值，当循环结束后，变量i的值变为5，此时我们再去点击每个li，也就是执行相应的匿名函数(看上面的代码)，这是变量i已经是5了，所以每个点击弹出5. 因为这里返回的每个匿名函数都是引用了同一个变量i，如果我们新建一个变量保存循环执行时当前的i的值，然后再让匿名函数应用这个变量，最后再返回这个匿名函数，这样就可以达到我们的目的了，这就是运用闭包来实现的！ b. 再来分析下运用闭包时的情况： 1234567891011var oli = document.getElementsByTagName('li'); var i; for(i = 0;i &lt; 5;i++)&#123; oli[i].onclick = (function(num)&#123; var a = num; // 为了说明问题 return function()&#123; alert(a); &#125; &#125;)(i) &#125; console.log(i); // 5 这里for循环执行时，给点击事件绑定的匿名函数传递i后立即执行返回一个内部的匿名函数，因为参数是按值传递的，所以此时形参num保存的就是当前i的值,然后赋值给局部变量 a，然后这个内部的匿名函数一直保存着a的引用，也就是一直保存着当前i的值。 所以循环执行完毕后点击每个li，返回的匿名函数执行弹出各自保存的 a 的引用的值。 ##4. 闭包的运用我们来看看闭包的用途。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。 1. 匿名自执行函数 我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包：1234567//将全部li字体变为红色(function()&#123; var els = document.getElementsByTagName('li'); for(var i = 0,lng = els.length;i &lt; lng;i++)&#123; els[i].style.color = 'red'; &#125; &#125;)(); 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此els,i,lng这些局部变量在执行完后很快就会被释放，节省内存！关键是这种机制不会污染全局对象。 2. 实现封装/模块化代码1234567891011121314151617var person= function()&#123; //变量作用域为函数内部，外部无法访问 var name = "default"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;();console.log(person.name);//直接访问，结果为undefined console.log(person.getName()); //defaultperson.setName("jozo"); console.log(person.getName()); //jozo 3. 实现面向对象中的对象这样不同的对象(类的实例)拥有独立的成员及状态，互不干涉。虽然JavaScript中没有类这样的机制，但是通过使用闭包，我们可以模拟出这样的机制。还是以上边的例子来讲:1234567891011121314151617181920212223function Person()&#123; var name = "default"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var person1= Person(); print(person1.getName()); john.setName("person1"); print(person1.getName()); // person1 var person2= Person(); print(person2.getName()); jack.setName("erson2"); print(erson2.getName()); //person2 Person的两个实例person1 和 person2 互不干扰！因为这两个实例对name这个成员的访问是独立的 。 ##5. 内存泄露及解决方案垃圾回收机制 说到内存管理，自然离不开JS中的垃圾回收机制，有两种策略来实现垃圾回收：标记清除 和 引用计数； 标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。 2008年为止，IE，Firefox，opera，chrome，Safari的javascript都用使用了该方式； 引用计数：跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个值的引用次数就是1，如果这个值再被赋值给另一个变量，则引用次数加1。相反，如果一个变量脱离了该值的引用，则该值引用次数减1，当次数为0时，就会等待垃圾收集器的回收。 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。早期的IE版本里（ie4-ie6）采用是计数的垃圾回收机制，闭包导致内存泄露的一个原因就是这个算法的一个缺陷。 我们知道，IE中有一部分对象并不是原生额javascript对象，例如，BOM和DOM中的对象就是以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数。因此，虽然IE的javascript引擎采用的是标记清除策略，但是访问COM对象依然是基于引用计数的，因此只要在IE中设计COM对象就会存在循环引用的问题！ 举个栗子：123456window.onload = function()&#123; var el = document.getElementById("id"); el.onclick = function()&#123; alert(el.id); &#125;&#125; 这段代码为什么会造成内存泄露？123el.onclick= function () &#123; alert(el.id);&#125;; 执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收； 解决方法：12345678window.onload = function()&#123; var el = document.getElementById("id"); var id = el.id; //解除循环引用 el.onclick = function()&#123; alert(id); &#125; el = null; // 将闭包引用的外部函数中活动对象清除&#125; ##6. 总结闭包的优缺点优点： 可以让一个变量常驻内存 (如果用的多了就成了缺点 避免全局变量的污染 私有化变量缺点 因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存 引起内存泄露]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JS（笔记4）--作用域与闭包]]></title>
    <url>%2F2016%2F10%2F24%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%EF%BC%88%E7%AC%94%E8%AE%B04%EF%BC%89-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[在讲解作用域闭包的内容之前，需要对以下概念有所掌握： JavaScript具有两种作用域：全局作用域和函数作用域，至于块作用域也不能说没有，比如说： try …catch…语句中，catch分句就是块作用域，还有with语句等。 ES6中的let关键字，可以用来在任意代码块中声明变量。 什么事立即执行函数表达式以及它的作用。 老生常谈什么是闭包闭包的概念：函数可以记住并访问所在的词法作用域时，即使函数是在当前词法作用域之外执行，这时就产生了闭包。123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); //这就是闭包的效果 函数bar()的词法作用域能够访问foo()的内部作用域，然后我们将bar()函数本身当作一个值进行传递。在foo()执行后，其返回值赋值给变量baz并调用baz()。在foo()执行后，通常会期待foo()的整个内部作用于都被销毁，因为我们知道引擎有垃圾回收机制来释放不在使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。但是，闭包的神奇之处在于可以阻止这件事情发生。事实上内部作用域依然存在，因此，没有被回收。那么是谁在使用这个内部作用域呢？当然是bar()在使用。由于bar()声明在foo()函数内部，所以它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以便bar()在以后的任何时间进行引用。bar()函数在foo()调用完成后，依旧持有对其作用域的引用，而这个引用就叫做闭包 当然，无论使用何种方式对函数类型的值进行传递，当函数在别处调用时都可以观察到闭包 当然，无论使用何种方式对函数类型的值进行传递，当函数在别处调用时都可以观察到闭包12345678910function foo()&#123; var a = 2; function baz()&#123; console.log(a)//2 &#125; bar(baz);&#125;function bar(fn)&#123; fn(); //这就是闭包&#125; 相比于上面代码的枯燥，这有一个更加常见的例子123456function wait(message)&#123; setTimeout(function time()&#123; console.log(message); &#125;, 1000);&#125;wait("hello clousre"); 简单分析一下这段代码：我们将一个名为time的内部函数传递给setTimeout(),time具有涵盖wait()作用域的闭包，因此，还保有对变量message的引用。wait(..)执行1000ms后，它的内部作用域并不会消失，time()函数依旧保有对wait()作用域的闭包，在引擎内部，内置的工具函数setTimeout()会持有一个对参数的引用，这个参数也许叫作fn或者func之类的。引擎会调用这个函数，而词法作用域在这个过程中保持完整。这就是闭包那么闭包有哪些应用呢？其实包括定时器，事件监听器，Ajax请求，跨窗口通信，Web Workers或者任何其他的异步(或者同步)任务中，只要使用回掉函数，实际上就是在使用闭包! 这里我们再看一个特别典型闭包的例子，但严格来说它并不是闭包。1234var a = 2;(function IIFE()&#123; console.log(a)&#125;)(); IIFE即立即执行函数表达式，第一个（）让函数变为函数表达式，第二个（）函数执行。为什么说他严格上来讲并不是闭包呢？因为在示例代码中函数并不是在它本身的词法作用域之外执行的，它在其定义时所在的作用域执行，a是通过词法作用域查找到的，并不是闭包发现的。尽管IIFE本身并不是观察闭包的恰当例子，但他的确创建了一个封闭的作用域，并且也是最常用来创建被封闭起来的闭包的工具。 循环和闭包说到闭包我们接触最早的也许就是for循环的例子：12345for(var i = 1; i&lt;6; i++)&#123; setTImeout(function time()&#123; console.log(i) &#125;, i*1000)&#125; 记得第一次看见这段代码的时候，那是被深深的虐到，作为C语言起手的同学，当时真的是一脸的懵逼，为什么会输出5个6， 为什么会输出5个6，为什么？当时其他人的讲解也是模模糊糊的，虽然提出了解决方法，当还是无法理解这其中的机制原理，所以，我痛下决心把它弄懂！也许只有我不懂吧！ 问：为什么会输出66666呢？答：能输出66666说明for循环内部的代码的确执行了5次。问：那6是从哪来的呢？答：6是我们循环的终止条件，所以输出6。问：那为什么不是循环一次，输出一个值， 1，2，3，4，5这样呢？答：setTimeout()函数是在循环结束时执行的，就算是你设置setTimeout(fn, 0),它也是在for循环完成后立即执行，总之就是在for循环执行完成后才执行。 好了，这就不难理解了为什么会输出66666了。但这也就引出了一个更深入的话题，代码中到底什么缺陷导致它的行为同语义暗示的不一致呢？ 缺陷是：我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。所以，实际的样子是这样。 而我们想象中的样子确是这样。 下面回到正题。既然明白了缺陷是什么，那么要怎样做才能达到我们想象中的样子呢？答案是我们需要在每一次迭代的过程中都创建一个闭包作用域。在上文中我们已经有所铺垫，IIFE会通过声明立即执行一个函数来创建作用域。so我们可以将代码改成下面的样子：1234567for(var i=1; i&lt;6; i++)&#123; (function()&#123; setTImeout(function time()&#123; console.log(i) &#125;, i*1000) &#125;)();&#125; 这样每一次迭代我们都创建了一个封闭的作用域(你可以想象为上图中黄色的矩形部分)。但是这样做仍旧不行，为什么呢？因为虽然每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来，但我们封闭的作用域是空的，所以必须传点东西过去才能实现我们想要的结果。12345678for(var i=1; i&lt;6; i++)&#123; (function()&#123; var j = i setTImeout(function time()&#123; console.log(j) &#125;, j*1000) &#125;)();&#125; ok!试试现在他能正常工作吗？对这段代码再进行一点改进1234567for(var i=1; i&lt;6; i++)&#123; (function(j)&#123; setTImeout(function time()&#123; console.log(j) &#125;, j*1000) &#125;)(i);&#125; 总的来说，就是在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数可以将新的作用域封闭在每个迭代内部，我们同时在迭代的过程中将每次迭代的i值作为参数传入进新的作用域，这样在迭代中创建的封闭作用域就都会含有一个具有正确值的变量供我们访问。ok,it’s work! 块作用域仔细思考我们前面的解决方案。我们使用IIFE在每次迭代时都创建一个新的作用域。也就是说，每次迭代我们都需要一个块作用域。前面我们提到，你需要对ES6中的let关键字进行了解，它可以用来劫持块作用域，并且在这个块作用域中声明一个变量。 本质上来讲它是将一个块转换成可以被关闭的作用域。123456for(var i=1; i&lt;6; i++)&#123; let j = i; //闭包的块作用域 setTImeout(function time()&#123; console.log(j) &#125;, j*1000)&#125; 如果将let声明在for循环的头部那么将会有一些特殊的行为，有多特殊呢？它会指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。不管这句话有多拗口，看看代码吧!12345for(let i=1; i&lt;6; i++)&#123; setTImeout(function time()&#123; console.log(i) &#125;, i*1000)&#125; 好的本节到这，再会！！]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JS（笔记3）--this解析2]]></title>
    <url>%2F2016%2F10%2F24%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%EF%BC%88%E7%AC%94%E8%AE%B03%EF%BC%89-this%E8%A7%A3%E6%9E%902%2F</url>
    <content type="text"><![CDATA[在上一节中”你不知道的JS –this解析1”介绍了this的两种绑定方式，默认绑定和隐式绑定，在这一节继续介绍this的另两种绑定方式显示绑定和new绑定。那么，我们要解决的问题是上节提到的：this丢失！ 显示绑定在隐式绑定中，我们必须在一个对象的内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接绑定到这个对象上，那么如果我们不想在每个对象内部包含函数引用，而想在每个对象上强制调用函数，该怎么做呢？这时就需要 call(绑定this, 其他参数…)和apply(绑定this, 其他参数…)方法出场了，这两个方法的第一个参数都是给this准备的，不同之处在于其他参数的形式上，他们两的其他参数对比如下： call(绑定this, “参数1”，”参数2”，”参数3”，”参数4”)；apply(绑定this, [“参数1”，”参数2”，”参数3”，”参数4”]); apply的其他参数是以数组序列形式存在的，它会在执行时将其解析成单个的参数再依次的传递到调用的函数中，这有什么用处呢？加入我们有一个数组 var arr = [1,2,3,4,5,6]; 现在我要找到其中的最大值，当然这里有很多方法了。既然这里讲到apply那么我们就用apply方法来解决这个问题。如果想要找到一组数中最大的一个，有一个简单的方法,使用Math.max(…)。但是，该方法并不能找出一个数组中的最大值，也就是说： Math.max(1,2,3,4,5); // 可以找到最大值5Math.max([1,2,3,4,5]); // 这就不行了，因为不接受以数组作为参数 我们的做法就是通过： Math.max.apply(null, [1,2,3,4,5]); //得到数组中的最大值5 还有很多其他方面的用处，比如push等等，似乎有点跑题了！！！不过我想说的就是通过call()和apply()这两种方法我们可以显式的绑定this到指定的对象！ 1234567function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;foo.call(obj);//2 但是，显式绑定仍旧无法解决this丢失绑定的问题。 硬绑定显式绑定的一个变种可以解决这个问题。 123456789101112function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 2 &#125;var bar = function()&#123; foo.call(obj);&#125;bar();// 2setTimeout(bar, 100); // 2bar.call(window); // 2 看看它是如何工作的：我们创建了一个函数bar(),并在他的内部手动调用foo.call(obj)。因此，强制把foo的this绑定到了obj，无论之后如何调用函数bar，它总会手动在obj上调用foo。这样的形式我们称之为硬绑定。硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值： 123456789101112function foo(something)&#123; console,log(this.a, something); return this.a + something;&#125;var obj = &#123; a: 2&#125;var bar = function()&#123; return foo.apply(obj, arguments);&#125;var b = bar(3); //2, 3console.log(b); //5 另一个常用的方法是创建一个可以重复使用的辅助函数： 123456789101112131415161718function foo(something)&#123; console,log(this.a, something); return this.a + something;&#125;//简单的辅助函数function bind(fn, obj)&#123; return function()&#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123; a:2&#125;var bar = bind(foo, obj);var b = bar(); //2, 3console.log(b); //5 硬绑定是一种非常常用的模式，所以ES5提供了内置的方法Function.prototype.bind,它的用法如下： 12345678910function foo(something)&#123; console,log(this.a, something); return this.a + something;&#125;var obj = &#123; a:2&#125;var bar = foo.bind(obj);var b = bar(3); //2, 3console.log(b); //5 bind(…)会返回一个硬编码的心函数，它会把指定的参数设置为this的上下文并调用原始函数。 new 绑定第四条规则，也是最后一条规则，在讲解他之前我们首先要澄清一个非常常见的关于javascript中函数和对象的误解。在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用new初始化类是会调用类中的构造函数。通常的形式是这样 1someThinges = new MyClass(...) javascript中也有个new操作符，但javascript中的new操作符的机制与面向类的语言完全不同。首先我们重新定义一下JavaScrit中的“构造函数”。在Javascript中，构造函数只是一些使用new操作符时被调用的函数。它并不会属于某个类，也不会实例化一个类。实际上它甚至都不能说是一种特殊的函数类型，它们只是被new操作符调用的普通函数而已。举例来说，思考一下Number()作为构造函数时的行为，ES5.1中这样描述它 Number构造函数当Number在new表达式中被调用时，它是一个构造函数：它会初始化新建的对象。 所以，包括内置对象函数在内的所有函数都可以用new来调用，这种函数被称为构造函数调用，这有个非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。使用new来调用函数，会自动执行下面的操作： 创建一个全新的对象 这个新对象会被执行[[prototype]]连接（之后会细说） 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数会自动返回这个对象。 1234567function foo(a)&#123; this.a = a&#125;var bar = new foo(2);console.log(bar) // foo &#123;a: 2&#125;console.log(bar.a); //2 使用new 来调用foo(…)时，我们会构造一个新的对象，并把它绑定到foo(…)调用中的this上。new是最后一种可以影响函数调用时this绑定行为的方法。我们称之为new绑定。 箭头函数我们之前介绍的四条规则已经可以包含所有正常使用函数。但是在ES6中介绍了一种无法使用这些规则的特殊函数类型：箭头函数箭头函数不是使用function关键字定义的，而是使用“ =&gt; ”定义。箭头函数不使用this的四种标准规则，而是根据外层作用域(函数或全局)来决定this。 123456789101112131415function foo()&#123; //返回一个箭头函数 return (a) =&gt;&#123; //this继承自foo() console.log(this.a); &#125;&#125;var obj1 = &#123; a: 2&#125;var obj2 = &#123; a: 3&#125;var bar = foo.call(obj1);bar.call(obj2); //2 不是3 foo()内部创建的箭头函数会捕获调用时foo()的this,由于foo()的this绑定到obj1，bar的this也会绑定到obj1上，而且箭头函数的绑定无法被修改！箭头函数最常用与回调函数中，例如事件处理器或者定时器： 12345678910function foo()&#123; setTimeout(()=&gt;&#123; //这里的this在词法上继承自foo()，也就是说只要foo()绑定到了obj1上，箭头函数的this也就绑定到了obj1上 console.log(this.a) &#125;,100)&#125;var obj1 = &#123; a: 2 &#125;foo.call(obj1); //2 箭头函数可以像bind(..)一样确保函数的this被绑定到指定的对象，此外，其重要性还体现在他用更常见的词法作用域取代了传统的this机制。实际上在，ES6之前我们就已经使了用一种几乎和箭头函数完全一样的模式。 123456789101112131415function foo()&#123; console.log(this); //Object &#123;a: 2&#125; var self = this; //词法作用域捕获this setTimeout(function()&#123; console.log(this); // Window &#123;external: Object, chrome: Object, document: document, obj1: Object, obj2: Object…&#125; console.log(self.a); &#125;, 100);&#125;var obj1 = &#123; a: 2 &#125;foo.call(obj1); //2 我分别在这段代码中foo()的内部，和setTimeout()的内部加了两行代码console.log(this)，当调用foo()函数并将其this绑定到obj1上时(即执行foo.call(obj1))，foo()内的this此时是Object {a: 2}，说明foo()函数中的this已经绑定到了obj1上，setTimeout()内的结果是Window…,如果你看了上一节《this全面解析（一）》的内容应该会很好理解，因为在setTimeout()方法中，函数传参相当于隐式赋值，调用方式自然运用默认规则，setTimeout()方法中函数的this指向window。为了让我们得到预期的结果，我们将foo()中的this保存下来(即var self = this),然后通过词法作用域的在setTimeout()方法中的函数中引用self变量。读者可以自行测试，如果不这样做得出的结果会是什么(undifined吗？自行验证一下吧！）好吧！一不小心又啰嗦的讲了这么多。虽然，self = this和箭头函数看起来都可以取代bind(),但本质上来说，他们想取代的是this机制。 小结如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到后就可以顺序应用下面这四条规则来判断this的绑定对象 是否由new调用？绑定到新创建的对象 是否由call()或apply()调用？绑定到指定的对象 是否由上下文对象调用？绑定到那个上下文对象 默认：严格模式undifined，非严格绑定到全局对象ES6中的箭头函数不会使用四条标准的绑定规则，而是根据词法作用域来决定this,具体来说，箭头函数会继承外层函数调用的this绑定(无论this绑定到了什么)，这其实和ES6之前代码中的self = this 机制一样]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JS（笔记2）--this解析1]]></title>
    <url>%2F2016%2F10%2F22%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%EF%BC%88%E7%AC%94%E8%AE%B02%EF%BC%89-this%E8%A7%A3%E6%9E%901%2F</url>
    <content type="text"><![CDATA[前言在 你不知道的JS（笔记1）– this的初探 中我们排除了对于this的错误理解，并且明白了每个函数的this是在调用时绑定的，完全取决于函数的调用位置。在本节中我们主要介绍一下几个主要内容： 什么是调用位置 绑定的规则 this此法 调用位置调用位置:就是函数在代码中被调用的位置(而不是声明位置)。要想回答this到底引用的是什么？只有仔细分析调用位置才能回答这个问题。而分析调用位置最重要的就是分析调用栈。下面是调用栈的定义。 调用栈：就是为了达到当前执行位置所调用的所有函数 123456789101112131415161718function baz()&#123; //当前调用栈是：baz //因此，当前调用位置是全局作用域 console.log("baz"); bar(); //bar的调用位置&#125;function bar()&#123; //当前调用栈是：baz -&gt; bar //因此，当前调用位置是在baz中 console.log("bar"); foo(); //foo的调用位置&#125;function foo()&#123; //当前调用栈是：baz -&gt; bar -&gt; foo //因此，当前调用位置是在baz中 console.log("foo");&#125;baz(); // baz的调用位置 绑定规则我们的思路是，通过找到函数的调用位置，然后判断需要应用规则中的哪一条。便可决定this的绑定对象。关于this的绑定规则主要是以下四种： 默认绑定 隐式绑定 显式绑定 new绑定 1.默认绑定默认绑定的典型类型是：独立函数调用。 思考如下代码：12345function foo ()&#123; console.log(this.a);&#125;var a = 2;foo(); // 2 调用foo()时，函数应用了默认绑定，this只想全局对象window(这是在非严格模式下，若是在严格模式下会报错)，所以this.a被解析成了全局变量a。所以，在不使用任何修饰的函数引用进行调用，只能使用默认绑定，无法应用其他规则。 2.隐式绑定隐式绑定的常见形式是在调用位置具有上下文对象，或者说被某个对象拥有或者包含。看如下代码：12345678function foo()&#123; console.log(this.a); &#125; var obj = &#123; a: 2, foo: foo &#125;; obj.foo(); // 2 这里函数foo()是预先定义好的，然后再将其添加为obj对象的引用属性。调用位置使用obj上下文来引用函数，因此可以说函数被调用时obj对象“拥有”或者“包含”它。无论你如何称呼这个模式，当foo()被调用时，它的前面确实是加上了obj的引用。当函数引用上下文对象时，隐式绑定规则就会把函数调用中的this绑定到这个上下文对象。所以，this.a和obj.a是一样的。 另一个需要注意的点是：对象属性引用链中只有最后一层在调用位置起作用 123456789101112function foo()&#123; console.log(this.a);&#125;var obj2 = &#123; a: 100, foo: foo&#125;;var obj1 = &#123; a: 1, obj2: obj2&#125;obj1.obj2.foo(); // 100 隐式绑定一个最常见的问题 一个最常见的问题就是：隐式绑定的函数会丢失绑定对象。也就是是说它会应用默认绑定，而把this绑定到全局对象或者undifined上，取决于是否是严格模式。 12345678910function foo()&#123; console.log(this.a);&#125;var obj =&#123; a: 2, foo: foo&#125;var bar = obj.foo; //函数别名var a = "global";bar(); // "global" 虽然bar是obj.foo的一个引用，但实际上，他引用的是foo函数本身， 因此， 此时的bar()其实是一个不带任何修饰的函数调用，因此，它应用了默认绑定。一种更微妙，更常见的并且更出乎意料的情况发生在传入回调函数时： 12345678910111213function foo()&#123; console.log(this.a);&#125;function callBack(fn)&#123; fn();&#125;var obj = &#123; a: 2, foo: foo&#125;var a = "global";callBack(obj.foo); // "global" 参数传递其实就是一种隐式赋值，这句话我们可以用下面的两段代码来详细的讲解： 1234567891011121314151617 var a = 1; function fn()&#123; alert(a); //1 a = 2; &#125; fn(); alert(a); // 2_ _ _ var a = 1; function fn(a)&#123; alert(a); //undifined a = 2; &#125; fn(); alert(a); // 1 思考一下结果是否与你想象的一致呢？在第一段代码中：首先，在全局作用域中，先通过变量提升，找到了标识符a和函数fn，a此时有个默认值为undifined。然后，在执行阶段我们先将变量a赋值为1，紧跟着函数fn()执行。此时，在函数域中，依旧应用变量提升的规则，但是什么都没找到，接着执行函数内的代码:alert(a),因为在函数中并没有找到变量a。所以，通过作用域链向上层的父级作用域中查找，我们找到了a,并且此时a的值已经被赋值为1，所以，alert(a)这句的结果就是1。下一句代码：a = 2,注意a的前面没有关键字var, 即这里的a是全局的，也就是说在执行这句代码时，他修改了全局作用域中a的值，即a现在为2。最后在执行alert(a)时，自然而然a的值便是2了。 在第二段代码中：同样，通过变量提升，我们找到了标识符a和函数fn，a此时的默认值也为undifined。开始执行，a首先被赋值为1。然后，函数执行，这里与第一段代码的不同之处在于，在函数fn中传入了参数a,那么这么做的结果就是：在函数域先运用变量提升的规则，不会像第一段代码中那样什么都找不到，而是相当于定义了一个值为undifined（调用的时候没有传入参数）的变量a,所以当执行函数域中的alert(a)时，结果就为undifined，而不会通过作用域链向上去查找，因为本函数中已经找到了，只不过是以参数的形式传入的。同理代码(a = 2)会修改a的值，即在函数域中，a的值现在为2（读者可以去尝试在函数中最后面alert一下a的值）。而在函数外执行alert(a),我们得到的结果便是1，因为该句代码是在全局中执行的，即会在全局中去查找变量a,而不会去访问函数域中的a。这也是因为，在JavaSceipt中子作用域可以访问父作用域而反过来却不行的规则。 回到我们this绑定丢失的话题上，说了这么多，我其实就是想说：参数传递其实就是一种隐式赋值.我们按照上面的方式来解析代码：在执行callBack(obj.foo)时，在函数作用域通过变量提升找到了参数fn,它的默认值为undifined，然后我们将参数传入，其实相当于(var fn = obj.foo),这就与前面的将其直接赋值给一个变量对等上了，然后再执行fn()，应用默认绑定，此时的this已经不指向obj了，而是指向window(严格模式)。 如果把函数传入内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别： 123456789function foo()&#123; console.log(this.a)&#125;var obj = &#123; a: 2, foo: foo&#125;var a = "global";setTimeout(obj.foo, 1000); //"global" JavaSceipt环境中内置的setTimeout()函数实现和下面的伪代码类似： 1234function setTimeout(fn, delay)&#123; //等待delay秒 fn(); //调用位置&#125; 就向你们看到的那样，回调函数丢失this绑定的情况是非常常见的，并且还有一种情况this的行为会出乎我们意料：调用回调函数的函数可能会修改this。由于无法控制回调函数的执行方式，因此就没有办法控制调用位置得到期望的绑定，下一节我们会介绍如何通过固定this来“修复“这个问题。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JS（笔记1）-- this的初探]]></title>
    <url>%2F2016%2F10%2F22%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%EF%BC%88%E7%AC%94%E8%AE%B01%EF%BC%89--%20this%E7%9A%84%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[最近，在看《你不知道的JS(上卷)》这本书，学下自己的笔记！！ this关键字是javascript最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有的函数作用域中。但是即使是非常有经验的javascript开发者也很难说出他到底指向什么。本节将分三个部分讲解javascript中的this： 为什么要使用this 两种常见的对于this的误解 this到底是什么 一、为什么要使用this 在书中通过两段代码的对比来说明为什么要使用this。第一段代码如下：这段代码在不同的上下问对象(me和you)中重复使用函数identify()和speak(),不用针对不同的对象编写不同版本的函数。 代码演示1234567891011121314151617function identify()&#123; return this.name.toUpperCase();&#125;function speak()&#123; var greeting = "hello, I am " + identify.call(this); console.log(greeting);&#125;var me = &#123; name: "zhou"&#125;var you = &#123; name: "reader"&#125;identify.call(me); //ZHOUidentify.call(you); //READERspeak.call(me); // hello, I am ZHOUspeak.call(you); // hello, I am READER 二、两种常见的对于this的误解误解1.指向函数自身常见的在函数内部引用自身的情况有：递归或者是一个在第一次被调用后自己接触绑定的事件处理器。 JavaScript的新手开发者(比如说我)通常认为：既然可以把函数看作一个对象，那就可以在调用函数时存储状态(属性的值)。现在我们来分析这个模式，让大家看到this并不像所想的那样指向函数本身。下面这段代码，我们想要记录函数foo被调用的次数： 123456789101112131415function foo(num)&#123; console.log("foo: " + num); this.count++; //记录foo被调用的次数 &#125; foo.count = 0; for(var i=0; i&lt;10; i++)&#123; if(i &gt; 5)&#123; foo(i) &#125; &#125; // foo: 6 // foo: 7 // foo: 8 // foo: 9 console.log(foo.count); // 0 为什么会是0呢? foo()函数中的console.log语句产生了4条输出，证明foo()确实被调用了4次，但foo.count仍然是0，所以，仅从字面上来理解，this指向函数自身是错误的。那么，问题的原因是什么呢？foo()函数是在全局作用域下执行的，this在这段代码中其实指向window，并且这段代码在无意中创建了一个全局变量count,他的值为NaN。 方法一 运用作用域(词法作用域)方法，该方法解决了我们遇到的问题，但是却没有直面this。123456789101112131415161718function foo(num)&#123; console.log("foo: " + num); data.count++; //记录foo被调用的次数&#125;var data =&#123; count: 0&#125;;for(var i=0; i&lt;10; i++)&#123; if(i &gt; 5)&#123; foo(i); &#125;&#125; // foo: 6 // foo: 7 // foo: 8 // foo: 9console.log(data.count);// 4 方法二 创建一个指向函数对象的词法标识符(变量)来引用它。同样该方法仍旧回避了this的问题。123456789101112131415function foo(num)&#123; console.log("foo: " + num); foo.count++; // foo指向它自身&#125;foo.count = 0;for(var i=0; i&lt;10; i++)&#123; if(i &gt; 5)&#123; foo(i); &#125;&#125; // foo: 6 // foo: 7 // foo: 8 // foo: 9console.log(foo.count);// 4 方法三 既然我们知道this在foo函数执行时指向了别处，那么我们需要做的就是强制this指向foo函数.123456789101112131415function foo(num)&#123; console.log("foo: " + num); this.count++;&#125;foo.count = 0;for(var i=0; i&lt;10; i++)&#123; if(i &gt; 5)&#123; foo.call(foo, i); //使用call()可以确保this指向函数本身 &#125;&#125; // foo: 6 // foo: 7 // foo: 8 // foo: 9console.log(foo.count);// 4 这次我们重this角度解决了问题 误解2.指向函数作用域第二种常见的误解是：this指向函数作用域。这个问题有点复杂，因为在某种情况下它是正确的，但在其他情况下他却是错误的。但一定要明白，this在任何情况下都不指向函数的作用域，在javascript内部作用域和对象确实很相似，可见的标识符都是他的属性，但作用域“对象”无法通过JavaScript代码访问，它存在于JavaScript引擎内部在文中给出了这样一段代码: 12345678function foo()&#123; var a = 2; this.bar();&#125;function bar()&#123; console.log(this.a);&#125;foo(); // ReferenceError: a is not defined 这段代码试图通过this联通foo()和bar()的词法作用域，从而让bar()可以访问foo()作用域的变量a。 三、this到底是个什么玩意？通过排除以上种种的误解，我们可以得出以下结论： this是在运行时进行绑定的，并不是在编写时绑定的。 this的绑定和函数声明的位置没有关系，只取决于函数的调用方式。 具体细节是：当一个函数被调用时，会创建一个活动记录(也称执行上下文(context))。这个记录会包含一些信息，比如： 函数在哪里被调用(调用栈)， 函数的调用方式， 传入的参数等，而this就是这个记录的一个属性，会在函数执行过程中被用到。 四、总结 随着你使用的模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱。因此，通过使用this隐式传递可以将API设计的更加简洁并且易于复用。 this既不指向函数自身，也不指向函数的作用域。 this实际上是函数被调用时发生的绑定，它的指向完全取决于函数在哪里被调用.]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Promise迷你书(后感)]]></title>
    <url>%2F2016%2F10%2F21%2FJavaScript_Promise%2F</url>
    <content type="text"><![CDATA[最近，在看《JavaScript Promise迷你书》这本书，从中学了好多，受益匪浅，希望坚持到底！！]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2016%2F10%2F20%2Fhello%2F</url>
    <content type="text"><![CDATA[Hello 这是我的第一篇博客，没写什么内容，但心情还是比较激动的，祝：接下来在工作和学习上可以试试顺利！！]]></content>
  </entry>
</search>